"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultisigECDSASmartAccount = exports.ECDSASmartAccount = exports.SmartAccount = void 0;
const smart_account_utils_1 = require("./smart-account-utils");
const Web3EthAccounts = __importStar(require("web3-eth-accounts"));
const adapters_1 = require("./adapters");
const utils_1 = require("./utils");
const web3_eth_accounts_1 = require("web3-eth-accounts");
const TypedDataEncoder_1 = require("./TypedDataEncoder");
function checkProvider(signer, operation) {
    if (signer._contextL2()) {
        return signer._contextL2();
    }
    throw new Error(`Missing provider: ${operation}`);
}
class SmartAccount extends adapters_1.AdapterL2 {
    constructor(signer, provider) {
        super();
        this._provider = provider;
        this._account = Array.isArray(signer.secret)
            ? signer.secret.map(secret => Web3EthAccounts.privateKeyToAccount(secret))
            : Web3EthAccounts.privateKeyToAccount(signer.secret);
        this._address = signer.address;
        this.payloadSigner = signer.payloadSigner || smart_account_utils_1.signPayloadWithECDSA;
        this.transactionBuilder = signer.transactionBuilder || smart_account_utils_1.populateTransactionECDSA;
    }
    _contextL2() {
        return this._provider;
    }
    get provider() {
        return this._contextL2();
    }
    get secret() {
        return Array.isArray(this._account)
            ? this._account.map(a => a.privateKey)
            : this._account.privateKey;
    }
    get address() {
        return this._address;
    }
    getAddress() {
        return this.address;
    }
    getNonce(blockNumber = 'latest') {
        return this.provider.eth.getTransactionCount(this.getAddress(), blockNumber);
    }
    connect(provider) {
        return new SmartAccount({
            address: this.getAddress(),
            secret: this.secret,
            payloadSigner: this.payloadSigner,
            transactionBuilder: this.transactionBuilder,
        }, provider ?? undefined);
    }
    async getBalance(token, blockTag = 'latest') {
        checkProvider(this, 'getBalance');
        return super.getBalance(token, blockTag);
    }
    async getAllBalances() {
        checkProvider(this, 'getAllAccountBalances');
        return super.getAllBalances();
    }
    async getDeploymentNonce() {
        checkProvider(this, 'getDeploymentNonce');
        return super.getDeploymentNonce();
    }
    async populateTransaction(tx) {
        return this.transactionBuilder({
            ...tx,
            from: tx.from ?? this.getAddress(),
        }, this.secret, this.provider);
    }
    async signTransaction(tx) {
        const populatedTx = (await this.populateTransaction(tx));
        const populatedTxHash = utils_1.EIP712Signer.getSignedDigest(populatedTx);
        populatedTx.customData = {
            ...populatedTx.customData,
            customSignature: this.payloadSigner(populatedTxHash, this.secret, this.provider),
        };
        return utils_1.EIP712.serialize(populatedTx);
    }
    async sendTransaction(tx) {
        checkProvider(this, 'broadcastTransaction');
        const signedTx = await this.signTransaction(tx);
        return (0, utils_1.getPriorityOpResponse)(this.provider, super.sendRawTransaction(signedTx), this._contextL2());
    }
    signMessage(message) {
        const signature = (0, web3_eth_accounts_1.signMessageWithPrivateKey)((0, utils_1.hashMessage)(message), Array.isArray(this.secret) ? this.secret[0] : this.secret);
        return signature.signature;
    }
    async signTypedData(domain, types, value) {
        const populated = await TypedDataEncoder_1.TypedDataEncoder.resolveNames(domain, types, value, async (name) => {
            return (0, utils_1.resolveAddress)(name, {
                resolveName: (name) => this.provider.eth.ens.getName(name),
            });
        });
        return this.payloadSigner(TypedDataEncoder_1.TypedDataEncoder.hash(populated.domain, types, populated.value), this.secret, this.provider);
    }
    async withdraw(transaction) {
        checkProvider(this, 'withdraw');
        return super.withdraw(transaction);
    }
    async transfer(transaction) {
        const transferTx = await super.transferTx(transaction);
        return this.sendTransaction(transferTx);
    }
}
exports.SmartAccount = SmartAccount;
class ECDSASmartAccount {
    static create(address, secret, provider) {
        return new SmartAccount({ address, secret }, provider);
    }
}
exports.ECDSASmartAccount = ECDSASmartAccount;
class MultisigECDSASmartAccount {
    static create(address, secret, provider) {
        return new SmartAccount({
            address,
            secret,
            payloadSigner: smart_account_utils_1.signPayloadWithMultipleECDSA,
            transactionBuilder: smart_account_utils_1.populateTransactionMultisigECDSA,
        }, provider);
    }
}
exports.MultisigECDSASmartAccount = MultisigECDSASmartAccount;
//# sourceMappingURL=smart-account.js.map
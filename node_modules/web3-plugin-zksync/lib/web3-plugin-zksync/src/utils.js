"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAddress = exports.getAddress = exports.toUtf8Bytes = exports.dataSlice = exports.id = exports.waitTxByHashConfirmationFinalized = exports.getPriorityOpL2Response = exports.getPriorityOpL1Response = exports.getPriorityOpResponse = exports.waitTxByHashConfirmation = exports.waitTxReceipt = exports.isAddressEq = exports.toJSON = exports.estimateCustomBridgeDepositL2Gas = exports.scaleGasLimit = exports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.getERC20DefaultBridgeData = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.hashBytecode = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.hashMessage = exports.MessagePrefix = exports.SignatureObject = exports.contractFunctionId = exports.concat = exports.toBytes = exports.evenHex = exports.NonceHolderContract = exports.L2BridgeContract = exports.L1BridgeContract = exports.IERC1271Contract = exports.IERC20Contract = exports.L1MessengerContract = exports.ContractDeployerContract = exports.BridgehubContract = exports.ZkSyncMainContract = void 0;
const sha256_js_1 = require("ethereum-cryptography/sha256.js");
const web3 = __importStar(require("web3"));
const web3Utils = __importStar(require("web3-utils"));
const web3Accounts = __importStar(require("web3-eth-accounts"));
const web3Types = __importStar(require("web3-types"));
const web3Abi = __importStar(require("web3-eth-abi"));
const web3_eth_accounts_1 = require("web3-eth-accounts");
const web3_eth_1 = require("web3-eth");
const web3_eth_abi_1 = require("web3-eth-abi");
const types_1 = require("./types");
const IZkSyncStateTransition_1 = require("./contracts/IZkSyncStateTransition");
const IBridgehub_1 = require("./contracts/IBridgehub");
const IContractDeployer_1 = require("./contracts/IContractDeployer");
const IL1Messenger_1 = require("./contracts/IL1Messenger");
const IERC20_1 = require("./contracts/IERC20");
const IERC1271_1 = require("./contracts/IERC1271");
const IL1ERC20Bridge_1 = require("./contracts/IL1ERC20Bridge");
const IL2Bridge_1 = require("./contracts/IL2Bridge");
const INonceHolder_1 = require("./contracts/INonceHolder");
const constants_1 = require("./constants");
const web3zksync_l1_1 = require("./web3zksync-l1");
const web3_1 = require("web3");
const web3_rpc_methods_1 = require("web3-rpc-methods");
const schemas_1 = require("./schemas");
const src_1 = require("../../web3.js/packages/web3-eth/src");
const web3_validator_1 = require("web3-validator");
__exportStar(require("./Eip712"), exports);
exports.ZkSyncMainContract = new web3.Contract(IZkSyncStateTransition_1.IZkSyncABI);
exports.BridgehubContract = new web3.Contract(IBridgehub_1.IBridgehubABI);
exports.ContractDeployerContract = new web3.Contract(IContractDeployer_1.IContractDeployerABI);
exports.L1MessengerContract = new web3.Contract(IL1Messenger_1.IL1MessengerABI);
exports.IERC20Contract = new web3.Contract(IERC20_1.IERC20ABI);
exports.IERC1271Contract = new web3.Contract(IERC1271_1.IERC1271ABI);
exports.L1BridgeContract = new web3.Contract(IL1ERC20Bridge_1.IL1BridgeABI);
exports.L2BridgeContract = new web3.Contract(IL2Bridge_1.IL2BridgeABI);
exports.NonceHolderContract = new web3.Contract(INonceHolder_1.INonceHolderABI);
const evenHex = (hex) => {
    return hex.length % 2 === 0 ? hex : `0x0${hex.slice(2)}`;
};
exports.evenHex = evenHex;
const toBytes = (number) => {
    const hex = web3Utils.toHex(number);
    return web3Utils.hexToBytes((0, exports.evenHex)(hex));
};
exports.toBytes = toBytes;
function concat(bytes) {
    return '0x' + bytes.map(d => web3Utils.toHex(d).substring(2)).join('');
}
exports.concat = concat;
function contractFunctionId(value) {
    return web3Utils.keccak256(web3Utils.utf8ToBytes(value));
}
exports.contractFunctionId = contractFunctionId;
function recoverSignerAddress(messageOrData, signature) {
    let message;
    if (typeof messageOrData !== 'string') {
        message = web3Abi.getEncodedEip712Data(messageOrData);
    }
    else {
        message = messageOrData;
    }
    const signatureObject = typeof signature === 'string'
        ? new SignatureObject(signature)
        : new SignatureObject((0, web3_eth_accounts_1.toUint8Array)(signature.r), (0, web3_eth_accounts_1.toUint8Array)(signature.s), signature.v);
    return web3Accounts.recover(web3Utils.keccak256(message), signatureObject.serialized, true);
}
class SignatureObject {
    constructor(rOrSignature, s, v) {
        if (typeof rOrSignature === 'string') {
            const bytes = web3Utils.hexToBytes(rOrSignature);
            if (bytes.length === 64) {
                const r = bytes.slice(0, 32);
                const s = bytes.slice(32, 64);
                const v = BigInt(s[0] & 0x80 ? 28 : 27);
                s[0] &= 0x7f;
                this.r = r;
                this.s = s;
                this.v = v;
            }
            else if (bytes.length === 65) {
                const r = bytes.slice(0, 32);
                const s = bytes.slice(32, 64);
                const v = BigInt(SignatureObject.getNormalizedV(bytes[64]));
                this.r = r;
                this.s = s;
                this.v = v;
            }
            else {
                throw new Error('Invalid signature length');
            }
        }
        else if (rOrSignature.r &&
            rOrSignature.s &&
            rOrSignature.v) {
            const ethereumSignature = rOrSignature;
            this.r = web3Utils.bytesToUint8Array(ethereumSignature.r);
            this.s = web3Utils.bytesToUint8Array(ethereumSignature.s);
            this.v = BigInt(ethereumSignature.v);
        }
        else {
            const signature = { r: rOrSignature, s: s, v: v };
            this.r = signature.r;
            this.s = signature.s;
            this.v = BigInt(signature.v);
        }
    }
    static getNormalizedV(v) {
        if (v === 0 || v === 27) {
            return 27;
        }
        if (v === 1 || v === 28) {
            return 28;
        }
        return v & 1 ? 27 : 28;
    }
    concat(datas) {
        return '0x' + datas.map(d => web3Utils.toHex(d).substring(2)).join('');
    }
    get yParity() {
        return this.v === 27n ? 0 : 1;
    }
    get serialized() {
        return this.concat([this.r, this.s, this.yParity ? '0x1c' : '0x1b']);
    }
    toString() {
        return `${this.r}${this.s.slice(2)}${web3Utils.toHex(this.v).slice(2)}`;
    }
}
exports.SignatureObject = SignatureObject;
exports.MessagePrefix = '\x19Ethereum Signed Message:\n';
function hashMessage(message) {
    if (typeof message === 'string') {
        message = toUtf8Bytes(message);
    }
    return web3Utils.keccak256(concat([toUtf8Bytes(exports.MessagePrefix), toUtf8Bytes(String(message.length)), message]));
}
exports.hashMessage = hashMessage;
function isETH(token) {
    return (isAddressEq(token, constants_1.LEGACY_ETH_ADDRESS) ||
        isAddressEq(token, constants_1.L2_BASE_TOKEN_ADDRESS) ||
        isAddressEq(token, constants_1.ETH_ADDRESS_IN_CONTRACTS));
}
exports.isETH = isETH;
function sleep(millis) {
    return new Promise(resolve => setTimeout(resolve, millis));
}
exports.sleep = sleep;
function layer1TxDefaults() {
    return {
        queueType: types_1.PriorityQueueType.Deque,
        opTree: types_1.PriorityOpTree.Full,
    };
}
exports.layer1TxDefaults = layer1TxDefaults;
function getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {
    const encodedMsg = new Uint8Array([
        0,
        1,
        ...web3Utils.hexToBytes(web3Utils.padLeft(web3Utils.toHex(txNumberInBlock), 2 * 2)),
        ...web3Utils.hexToBytes(constants_1.L1_MESSENGER_ADDRESS),
        ...web3Utils.hexToBytes(web3Utils.padLeft(sender, 32 * 2)),
        ...web3Utils.hexToBytes(web3Utils.keccak256(msg)),
    ]);
    return web3Utils.keccak256(encodedMsg);
}
exports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;
function getDeployedContracts(receipt) {
    const addressBytesLen = 40;
    return (receipt.logs
        .filter(log => log.topics &&
        log.topics[0] ===
            contractFunctionId('ContractDeployed(address,bytes32,address)') &&
        log.address &&
        isAddressEq(log.address, constants_1.CONTRACT_DEPLOYER_ADDRESS))
        .map(log => {
        if (!log.topics)
            throw new Error('No topics in log');
        const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;
        const bytecodeHash = log.topics[2];
        const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;
        return {
            sender: web3Utils.toChecksumAddress(sender),
            bytecodeHash: web3Utils.toHex(bytecodeHash),
            deployedAddress: web3Utils.toChecksumAddress(address),
        };
    }));
}
exports.getDeployedContracts = getDeployedContracts;
function create2Address(sender, bytecodeHash, salt, input = '') {
    const prefix = web3Utils.keccak256(web3Utils.utf8ToBytes('zksyncCreate2'));
    const inputHash = web3Utils.keccak256(input);
    const addressBytes = web3Utils
        .keccak256(concat([prefix, web3Utils.padLeft(sender, 32 * 2), salt, bytecodeHash, inputHash]))
        .slice(26);
    return web3Utils.toChecksumAddress(addressBytes);
}
exports.create2Address = create2Address;
function createAddress(sender, senderNonce) {
    const prefix = web3Utils.keccak256(web3Utils.utf8ToBytes('zksyncCreate'));
    const addressBytes = web3Utils
        .keccak256(concat([
        prefix,
        web3Utils.padLeft(sender, 32 * 2),
        web3Utils.padLeft(web3Utils.toHex(senderNonce), 32 * 2),
    ]))
        .slice(26);
    return web3Utils.toChecksumAddress(addressBytes);
}
exports.createAddress = createAddress;
async function checkBaseCost(baseCost, value) {
    if (baseCost > (await value)) {
        throw new Error('The base cost of performing the priority operation is higher than the provided value parameter ' +
            `for the transaction: baseCost: ${baseCost}, provided value: ${value}!`);
    }
}
exports.checkBaseCost = checkBaseCost;
function hashBytecode(bytecode) {
    const bytecodeAsArray = web3Utils.bytesToUint8Array(bytecode);
    if (bytecodeAsArray.length % 32 !== 0) {
        throw new Error('The bytecode length in bytes must be divisible by 32!');
    }
    if (bytecodeAsArray.length > constants_1.MAX_BYTECODE_LEN_BYTES) {
        throw new Error(`Bytecode can not be longer than ${constants_1.MAX_BYTECODE_LEN_BYTES} bytes!`);
    }
    const hashStr = web3Utils.toHex((0, sha256_js_1.sha256)(Buffer.from(bytecodeAsArray)));
    const hash = web3Utils.bytesToUint8Array(hashStr);
    const bytecodeLengthInWords = bytecodeAsArray.length / 32;
    if (bytecodeLengthInWords % 2 === 0) {
        throw new Error('Bytecode length in 32-byte words must be odd!');
    }
    const bytecodeLengthPadded = web3Utils.bytesToUint8Array(web3Utils.padLeft(bytecodeLengthInWords, 2 * 2));
    const codeHashVersion = new Uint8Array([1, 0]);
    hash.set(codeHashVersion, 0);
    hash.set(bytecodeLengthPadded, 2);
    return hash;
}
exports.hashBytecode = hashBytecode;
let ZkSyncABIEvents = null;
const getZkSyncEvents = () => {
    if (ZkSyncABIEvents === null) {
        ZkSyncABIEvents = IZkSyncStateTransition_1.IZkSyncABI.filter(e => e.type === 'event').map(e => ({
            ...e,
            signature: (0, web3_eth_abi_1.encodeEventSignature)((0, web3_eth_abi_1.jsonInterfaceMethodToString)(e)),
        }));
    }
    return ZkSyncABIEvents;
};
function getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {
    let txHash = null;
    for (const log of txReceipt.logs) {
        if (!isAddressEq(log.address, zkSyncAddress)) {
            continue;
        }
        try {
            const decoded = (0, web3_eth_1.decodeEventABI)(web3_eth_1.ALL_EVENTS_ABI, log, getZkSyncEvents());
            if (decoded && decoded.returnValues && decoded.returnValues.txHash !== null) {
                txHash = decoded.returnValues.txHash ? String(decoded.returnValues.txHash) : null;
            }
        }
        catch {
        }
    }
    if (!txHash) {
        throw new Error('Failed to parse tx logs!');
    }
    return txHash;
}
exports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;
const ADDRESS_MODULO = 2n ** 160n;
function applyL1ToL2Alias(address) {
    return web3Utils.padLeft(web3Utils.toHex((BigInt(address) + BigInt(constants_1.L1_TO_L2_ALIAS_OFFSET)) % ADDRESS_MODULO), 20 * 2);
}
exports.applyL1ToL2Alias = applyL1ToL2Alias;
function undoL1ToL2Alias(address) {
    let result = BigInt(address) - BigInt(constants_1.L1_TO_L2_ALIAS_OFFSET);
    if (result < 0n) {
        result += ADDRESS_MODULO;
    }
    return web3Utils.padLeft(web3Utils.toHex(result), 20 * 2);
}
exports.undoL1ToL2Alias = undoL1ToL2Alias;
async function getERC20DefaultBridgeData(l1TokenAddress, context) {
    if (isAddressEq(l1TokenAddress, constants_1.LEGACY_ETH_ADDRESS)) {
        l1TokenAddress = constants_1.ETH_ADDRESS_IN_CONTRACTS;
    }
    const token = new context.eth.Contract(IERC20_1.IERC20ABI, l1TokenAddress);
    const name = isAddressEq(l1TokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS)
        ? 'Ether'
        : await token.methods.name().call();
    const symbol = isAddressEq(l1TokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS)
        ? 'ETH'
        : await token.methods.symbol().call();
    const decimals = isAddressEq(l1TokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS)
        ? 18
        : await token.methods.decimals().call();
    return web3Abi.encodeParameters(['string', 'string', 'uint256'], [name, symbol, Number(decimals)]);
}
exports.getERC20DefaultBridgeData = getERC20DefaultBridgeData;
async function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, bridgeData) {
    return exports.L2BridgeContract.methods
        .finalizeDeposit(l1Sender, l2Receiver, l1TokenAddress, amount, bridgeData)
        .encodeABI();
}
exports.getERC20BridgeCalldata = getERC20BridgeCalldata;
function isECDSASignatureCorrect(address, message, signature) {
    try {
        return isAddressEq(address, recoverSignerAddress(message, signature));
    }
    catch {
        return false;
    }
}
async function isEIP1271SignatureCorrect(context, address, msgHash, signature) {
    const accountContract = new web3.Contract(IERC1271_1.IERC1271ABI, address, context);
    const result = await accountContract.methods.isValidSignature(msgHash, signature).call();
    return result === constants_1.EIP1271_MAGIC_VALUE;
}
async function isSignatureCorrect(context, address, message, signature) {
    let isContractAccount;
    if (context.provider) {
        const code = await web3.eth.getCode(context, address, undefined, web3Types.DEFAULT_RETURN_FORMAT);
        isContractAccount = web3Utils.bytesToUint8Array(code).length !== 0;
    }
    if (!isContractAccount) {
        return isECDSASignatureCorrect(address, message, signature);
    }
    else {
        const msgHash = web3Accounts.hashMessage(typeof message === 'string'
            ? message
            : web3Utils.bytesToHex(message));
        return await isEIP1271SignatureCorrect(context, address, msgHash, signature);
    }
}
async function isMessageSignatureCorrect(context, address, message, signature) {
    return await isSignatureCorrect(context, address, web3Utils.toHex(message), signature);
}
exports.isMessageSignatureCorrect = isMessageSignatureCorrect;
async function isTypedDataSignatureCorrect(context, address, domain, types, value, signature) {
    const typedDataStruct = {
        domain,
        types,
        primaryType: 'Transaction',
        message: value,
    };
    return isSignatureCorrect(context, address, typedDataStruct, signature);
}
exports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;
async function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {
    from ?? (from = web3Accounts.create().address);
    if (await providerL2.isBaseToken(token)) {
        return await providerL2.estimateL1ToL2Execute({
            contractAddress: to,
            gasPerPubdataByte: gasPerPubdataByte,
            caller: from,
            calldata: '0x',
            l2Value: amount,
        });
    }
    else {
        const bridgeAddresses = await providerL2.getDefaultBridgeAddresses();
        const value = 0;
        const l1BridgeAddress = bridgeAddresses.sharedL1;
        const l2BridgeAddress = bridgeAddresses.sharedL2;
        const bridgeData = await getERC20DefaultBridgeData(token, providerL1);
        return estimateCustomBridgeDepositL2Gas(providerL2, l1BridgeAddress, l2BridgeAddress, isAddressEq(token, constants_1.LEGACY_ETH_ADDRESS) ? constants_1.ETH_ADDRESS_IN_CONTRACTS : token, amount, to, bridgeData, from, gasPerPubdataByte, value);
    }
}
exports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas;
function scaleGasLimit(gasLimit) {
    return ((gasLimit * BigInt(constants_1.L1_FEE_ESTIMATION_COEF_NUMERATOR)) /
        BigInt(constants_1.L1_FEE_ESTIMATION_COEF_DENOMINATOR));
}
exports.scaleGasLimit = scaleGasLimit;
async function estimateCustomBridgeDepositL2Gas(providerL2, l1BridgeAddress, l2BridgeAddress, token, amount, to, bridgeData, from, gasPerPubdataByte, l2Value) {
    const calldata = await getERC20BridgeCalldata(token, from, to, amount, bridgeData);
    return providerL2.estimateL1ToL2Execute({
        caller: applyL1ToL2Alias(l1BridgeAddress),
        contractAddress: l2BridgeAddress,
        gasPerPubdataByte: gasPerPubdataByte,
        calldata: calldata,
        l2Value: l2Value,
    });
}
exports.estimateCustomBridgeDepositL2Gas = estimateCustomBridgeDepositL2Gas;
function toJSON(object) {
    return JSON.stringify(object, (_, value) => {
        if (typeof value === 'bigint') {
            return value.toString();
        }
        return value;
    }, 2);
}
exports.toJSON = toJSON;
function isAddressEq(a, b) {
    return a.toLowerCase() === b.toLowerCase();
}
exports.isAddressEq = isAddressEq;
const checkReceipt = (hash, receipt) => {
    if (!receipt) {
        throw new Error(`Transaction with hash ${hash} not found`);
    }
    if (Number(receipt.status) === 0) {
        throw new Error(`Transaction ${hash} failed with status 0`);
    }
    return receipt;
};
const customGetTransactionReceipt = async (web3Context, transactionHash, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) => {
    const response = await web3_rpc_methods_1.ethRpcMethods.getTransactionReceipt(web3Context.requestManager, transactionHash);
    return (0, web3_validator_1.isNullish)(response)
        ? response
        : web3Utils.format(schemas_1.ZKTransactionReceiptSchema, response, returnFormat ?? web3Context.defaultReturnFormat);
};
async function waitTxReceipt(web3Eth, txHash) {
    const receipt = await (0, src_1.waitForTransactionReceipt)(web3Eth, txHash, web3_1.DEFAULT_RETURN_FORMAT, customGetTransactionReceipt);
    return checkReceipt(txHash, receipt);
}
exports.waitTxReceipt = waitTxReceipt;
async function waitTxByHashConfirmation(web3Eth, txHash, waitConfirmations = 1) {
    const receipt = await waitTxReceipt(web3Eth, txHash);
    while (true) {
        const blockNumber = await web3Eth.getBlockNumber();
        if (web3Utils.toBigInt(blockNumber) - web3Utils.toBigInt(receipt.blockNumber) + 1n >=
            waitConfirmations) {
            return receipt;
        }
        await sleep(500);
    }
}
exports.waitTxByHashConfirmation = waitTxByHashConfirmation;
const getPriorityOpResponse = (context, l1TxPromise, contextL2) => {
    if (context instanceof web3zksync_l1_1.Web3ZKsyncL1) {
        return (0, exports.getPriorityOpL1Response)(context, l1TxPromise, contextL2);
    }
    else {
        return (0, exports.getPriorityOpL2Response)(context, l1TxPromise);
    }
};
exports.getPriorityOpResponse = getPriorityOpResponse;
const getPriorityOpL1Response = async (context, l1TxPromise, contextL2) => {
    const hash = await l1TxPromise;
    return {
        hash,
        waitL1Commit: async () => {
            return waitTxByHashConfirmation(context.eth, hash, 1);
        },
        wait: async () => {
            return waitTxByHashConfirmation(context.eth, hash, 1);
        },
        waitFinalize: async () => {
            const receipt = await waitTxReceipt(context.eth, hash);
            const l2TxHash = await contextL2.getL2TransactionFromPriorityOp(receipt);
            if (!contextL2) {
                return {
                    transactionHash: l2TxHash,
                };
            }
            return await waitTxByHashConfirmationFinalized(contextL2.eth, l2TxHash, 1);
        },
    };
};
exports.getPriorityOpL1Response = getPriorityOpL1Response;
const getPriorityOpL2Response = async (context, txPromise) => {
    const hash = await txPromise;
    return {
        hash,
        wait: async () => {
            return waitTxByHashConfirmation(context.eth, hash, 1);
        },
        waitFinalize: async () => {
            return await waitTxByHashConfirmationFinalized(context.eth, hash, 1);
        },
    };
};
exports.getPriorityOpL2Response = getPriorityOpL2Response;
async function waitTxByHashConfirmationFinalized(web3Eth, txHash, waitConfirmations = 1, blogTag) {
    while (true) {
        const receipt = await waitTxReceipt(web3Eth, txHash);
        const block = await web3Eth.getBlock(blogTag ?? 'finalized');
        if (web3Utils.toBigInt(block.number) - web3Utils.toBigInt(receipt.blockNumber) + 1n >=
            waitConfirmations) {
            return receipt;
        }
        await sleep(500);
    }
}
exports.waitTxByHashConfirmationFinalized = waitTxByHashConfirmationFinalized;
function id(value) {
    return web3Utils.keccak256(toUtf8Bytes(value));
}
exports.id = id;
function dataSlice(data, start, end) {
    const bytes = (0, exports.toBytes)(data);
    if (end != null && end > bytes.length) {
        throw new Error('cannot slice beyond data bounds');
    }
    return web3Utils.toHex(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
exports.dataSlice = dataSlice;
function toUtf8Bytes(str) {
    if (typeof str !== 'string') {
        throw new Error(`invalid string value ${str}`);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (!(i < str.length && (c2 & 0xfc00) === 0xdc00)) {
                throw new Error(`invalid surrogate pair ${str}`);
            }
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return new Uint8Array(result);
}
exports.toUtf8Bytes = toUtf8Bytes;
function getAddress(address) {
    if (!web3Utils.isAddress(address)) {
        throw new Error(`Invalid address ${address}`);
    }
    return address;
}
exports.getAddress = getAddress;
async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === '0x0000000000000000000000000000000000000000') {
        if (typeof target === 'string') {
            throw new Error(`ENS name resolution failed for ${target}`);
        }
        throw new Error(`invalid AddressLike value; did not resolve to a value address`);
    }
    return getAddress(result);
}
function resolveAddress(target, resolver) {
    if (typeof target === 'string') {
        if (target.match(/^0x[0-9a-f]{40}$/i)) {
            return getAddress(target);
        }
        if (resolver == null) {
            throw new Error('ENS name resolution requires a provider');
        }
        return checkAddress(target, resolver.resolveName(target));
    }
    else if (target && typeof target.getAddress === 'function') {
        return checkAddress(target, target.getAddress());
    }
    else if (target && typeof target.then === 'function') {
        return checkAddress(target, target);
    }
    throw new Error('unsupported addressable value');
}
exports.resolveAddress = resolveAddress;
//# sourceMappingURL=utils.js.map
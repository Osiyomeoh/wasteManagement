"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3ZKsyncL2 = void 0;
const web3_types_1 = require("web3-types");
const web3_utils_1 = require("web3-utils");
const web3_rpc_methods_1 = require("web3-rpc-methods");
const web3_validator_1 = require("web3-validator");
const utils_1 = require("./utils");
const types_1 = require("./types");
const web3zksync_1 = require("./web3zksync");
const schemas_1 = require("./schemas");
const IEthToken_1 = require("./contracts/IEthToken");
const constants_1 = require("./constants");
const IL2Bridge_1 = require("./contracts/IL2Bridge");
const IERC20_1 = require("./contracts/IERC20");
class Web3ZKsyncL2 extends web3zksync_1.Web3ZkSync {
    async getZKTransactionReceipt(transactionHash, returnFormat = web3_types_1.DEFAULT_RETURN_FORMAT) {
        const transactionHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, transactionHash, web3_types_1.DEFAULT_RETURN_FORMAT);
        const response = await web3_rpc_methods_1.ethRpcMethods.getTransactionReceipt(this.requestManager, transactionHashFormatted);
        return (0, web3_validator_1.isNullish)(response)
            ? response
            : (0, web3_utils_1.format)(schemas_1.ZKTransactionReceiptSchema, response, returnFormat ?? this.defaultReturnFormat);
    }
    async _getPriorityOpConfirmationL2ToL1Log(txHash, index = 0) {
        const hash = (0, web3_utils_1.toHex)(txHash);
        const receipt = await this.getZKTransactionReceipt(hash);
        if (!receipt) {
            throw new Error('Transaction is not mined!');
        }
        const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([, log]) => (0, utils_1.isAddressEq)(log.sender, constants_1.BOOTLOADER_FORMAL_ADDRESS));
        const [l2ToL1LogIndex, l2ToL1Log] = messages[index];
        return {
            l2ToL1LogIndex,
            l2ToL1Log,
            l1BatchTxId: receipt.l1BatchTxIndex,
        };
    }
    async getPriorityOpConfirmation(txHash, index = 0) {
        const { l2ToL1LogIndex, l2ToL1Log, l1BatchTxId } = await this._getPriorityOpConfirmationL2ToL1Log(txHash, index);
        const proof = await this._rpc.getL2ToL1LogProof(txHash, l2ToL1LogIndex);
        return {
            l1BatchNumber: l2ToL1Log.l1BatchNumber,
            l2MessageIndex: proof.id,
            l2TxNumberInBlock: l1BatchTxId,
            proof: proof.proof,
        };
    }
    async getL2TransactionFromPriorityOp(receipt) {
        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
        let status = null;
        do {
            status = await this.getTransactionStatus(l2Hash);
            await (0, utils_1.sleep)(this.transactionPollingInterval);
        } while (status === types_1.TransactionStatus.NotFound);
        return l2Hash;
    }
    async getTransactionStatus(txHash) {
        let tx;
        try {
            tx = await this.eth.getTransaction(txHash);
        }
        catch { }
        if (!tx) {
            return types_1.TransactionStatus.NotFound;
        }
        if (!tx.blockNumber) {
            return types_1.TransactionStatus.Processing;
        }
        const verifiedBlock = (await this.eth.getBlock('finalized'));
        if (tx.blockNumber <= verifiedBlock.number) {
            return types_1.TransactionStatus.Finalized;
        }
        return types_1.TransactionStatus.Committed;
    }
    async getWithdrawTx(transaction) {
        var _a;
        const { ...tx } = transaction;
        const isEthBasedChain = await this.isEthBasedChain();
        if ((0, utils_1.isAddressEq)(tx.token, constants_1.LEGACY_ETH_ADDRESS) && !isEthBasedChain) {
            tx.token = await this.l2TokenAddress(constants_1.ETH_ADDRESS_IN_CONTRACTS);
        }
        else if (await this.isBaseToken(tx.token)) {
            tx.token = constants_1.L2_BASE_TOKEN_ADDRESS;
        }
        if ((tx.to === null || tx.to === undefined) &&
            (tx.from === null || tx.from === undefined)) {
            throw new Error('Withdrawal target address is undefined!');
        }
        tx.to ?? (tx.to = tx.from);
        tx.overrides ?? (tx.overrides = {});
        (_a = tx.overrides).from ?? (_a.from = tx.from);
        if ((0, utils_1.isETH)(tx.token)) {
            if (!tx.overrides?.value) {
                tx.overrides.value = (0, web3_utils_1.toHex)(tx.amount);
            }
            const passedValue = BigInt(tx.overrides?.value ?? 0);
            if (passedValue !== BigInt(tx.amount)) {
                throw new Error('The tx.value is not equal to the value withdrawn!');
            }
            const ethL2Token = new this.eth.Contract(IEthToken_1.Abi, constants_1.L2_BASE_TOKEN_ADDRESS);
            const populatedTx = ethL2Token.methods
                .withdraw(tx.to)
                .populateTransaction(tx.overrides);
            if (tx.paymasterParams) {
                return {
                    ...populatedTx,
                    customData: {
                        paymasterParams: tx.paymasterParams,
                    },
                };
            }
            return populatedTx;
        }
        if (!tx.bridgeAddress) {
            const bridgeAddresses = await this.getDefaultBridgeAddresses();
            tx.bridgeAddress = bridgeAddresses.sharedL2;
        }
        const bridge = new this.eth.Contract(IL2Bridge_1.IL2BridgeABI, tx.bridgeAddress);
        const populatedTx = bridge.methods
            .withdraw(tx.to, tx.token, tx.amount)
            .populateTransaction(tx.overrides);
        if (tx.paymasterParams) {
            return {
                ...populatedTx,
                customData: {
                    paymasterParams: tx.paymasterParams,
                },
            };
        }
        return populatedTx;
    }
    async getTransferTx(transaction) {
        var _a;
        const { ...tx } = transaction;
        const isEthBasedChain = await this.isEthBasedChain();
        if (tx.token && (0, utils_1.isAddressEq)(tx.token, constants_1.LEGACY_ETH_ADDRESS) && !isEthBasedChain) {
            tx.token = await this.l2TokenAddress(constants_1.ETH_ADDRESS_IN_CONTRACTS);
        }
        else if (!tx.token || (await this.isBaseToken(tx.token))) {
            tx.token = constants_1.L2_BASE_TOKEN_ADDRESS;
        }
        tx.overrides ?? (tx.overrides = {});
        (_a = tx.overrides).from ?? (_a.from = tx.from);
        if ((0, utils_1.isETH)(tx.token)) {
            if (tx.paymasterParams) {
                return {
                    ...tx.overrides,
                    type: constants_1.EIP712_TX_TYPE,
                    to: tx.to,
                    value: tx.amount,
                    customData: {
                        paymasterParams: tx.paymasterParams,
                    },
                };
            }
            return {
                ...tx.overrides,
                to: tx.to,
                value: tx.amount,
            };
        }
        else {
            const token = new this.eth.Contract(IERC20_1.IERC20ABI, tx.token);
            const populatedTx = token.methods
                .transfer(tx.to, tx.amount)
                .populateTransaction(tx.overrides);
            if (tx.paymasterParams) {
                return {
                    ...populatedTx,
                    customData: {
                        paymasterParams: tx.paymasterParams,
                    },
                };
            }
            return populatedTx;
        }
    }
    static initWithDefaultProvider(zksyncNetwork = types_1.Network.Localhost) {
        switch (zksyncNetwork) {
            case types_1.Network.Localhost:
                return new Web3ZKsyncL2('http://localhost:3050');
            case types_1.Network.Sepolia:
                return new Web3ZKsyncL2('https://sepolia.era.zksync.dev');
            case types_1.Network.Mainnet:
                return new Web3ZKsyncL2('https://mainnet.era.zksync.io');
            case types_1.Network.EraTestNode:
                return new Web3ZKsyncL2('http://localhost:8011');
            default:
                return new Web3ZKsyncL2('http://localhost:3050');
        }
    }
    async getBalance(address, blockTag, tokenAddress) {
        if (!tokenAddress || (await this.isBaseToken(tokenAddress))) {
            return this.eth.getBalance(address, blockTag);
        }
        else {
            try {
                return this.getTokenBalance(tokenAddress, address);
            }
            catch {
                return 0n;
            }
        }
    }
}
exports.Web3ZKsyncL2 = Web3ZKsyncL2;
//# sourceMappingURL=web3zksync-l2.js.map
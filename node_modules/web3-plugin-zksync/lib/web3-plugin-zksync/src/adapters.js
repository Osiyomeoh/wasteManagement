"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AdapterL2 = exports.AdapterL1 = void 0;
const web3Utils = __importStar(require("web3-utils"));
const Web3EthAbi = __importStar(require("web3-eth-abi"));
const web3_1 = require("web3");
const Web3 = __importStar(require("web3"));
const web3_utils_1 = require("web3-utils");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const types_1 = require("./types");
const IZkSyncStateTransition_1 = require("./contracts/IZkSyncStateTransition");
const IBridgehub_1 = require("./contracts/IBridgehub");
const IERC20_1 = require("./contracts/IERC20");
const IL1Bridge_1 = require("./contracts/IL1Bridge");
const IL1SharedBridge_1 = require("./contracts/IL1SharedBridge");
const IL2Bridge_1 = require("./contracts/IL2Bridge");
const INonceHolder_1 = require("./contracts/INonceHolder");
class AdapterL1 {
    _contextL2() {
        throw new Error('Must be implemented by the derived class!');
    }
    _contextL1() {
        throw new Error('Must be implemented by the derived class!');
    }
    async getMainContract(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        const address = await this._contextL2().getMainContract(returnFormat);
        const contract = new Web3.Contract(IZkSyncStateTransition_1.IZkSyncABI, address, returnFormat);
        contract.setProvider(this._contextL2().provider);
        return contract;
    }
    async getBridgehubContract(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        const address = await this._contextL2().getBridgehubContractAddress();
        return new (this._contextL1().eth.Contract)(IBridgehub_1.IBridgehubABI, address, returnFormat);
    }
    async getL1BridgeContracts(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        const addresses = await this._contextL2().getDefaultBridgeAddresses();
        const erc20 = new (this._contextL1().eth.Contract)(IERC20_1.IERC20ABI, addresses.erc20L1, returnFormat);
        const weth = new (this._contextL1().eth.Contract)(IERC20_1.IERC20ABI, addresses.wethL1, returnFormat);
        const shared = new (this._contextL1().eth.Contract)(IL1SharedBridge_1.Abi, addresses.sharedL1, returnFormat);
        return {
            erc20,
            weth,
            shared,
        };
    }
    async getBaseToken() {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        return bridgehub.methods.baseToken(chainId).call();
    }
    async isETHBasedChain() {
        return this._contextL2().isEthBasedChain();
    }
    async getBalanceL1(token, blockTag) {
        token ?? (token = constants_1.LEGACY_ETH_ADDRESS);
        return await this._contextL1().getBalance(this.getAddress(), blockTag, token);
    }
    async getAllowanceL1(token, bridgeAddress, blockTag) {
        if (!bridgeAddress) {
            const bridgeContracts = await this.getL1BridgeContracts();
            bridgeAddress = bridgeContracts.shared.options.address;
        }
        const erc20 = new (this._contextL1().eth.Contract)(IERC20_1.IERC20ABI, token);
        return erc20.methods
            .allowance(this.getAddress(), bridgeAddress, {
            blockTag,
        })
            .call();
    }
    async l2TokenAddress(token) {
        return this._contextL2().l2TokenAddress(token);
    }
    async approveERC20(token, amount, overrides) {
        if ((0, utils_1.isETH)(token)) {
            throw new Error("ETH token can't be approved! The address of the token does not exist on L1.");
        }
        overrides ?? (overrides = {});
        let bridgeAddress = overrides.bridgeAddress;
        const erc20 = new (this._contextL1().eth.Contract)(IERC20_1.IERC20ABI, token);
        if (!bridgeAddress) {
            bridgeAddress = (await this.getL1BridgeContracts()).shared.options.address;
        }
        else {
            delete overrides.bridgeAddress;
        }
        return erc20.methods.approve(bridgeAddress, amount, overrides).send({
            from: this.getAddress(),
        });
    }
    async getBaseCost(params) {
        const bridgehub = await this.getBridgehubContract();
        const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };
        parameters.gasPrice ?? (parameters.gasPrice = (await this._contextL1().eth.calculateFeeData()).gasPrice);
        parameters.gasPerPubdataByte ?? (parameters.gasPerPubdataByte = constants_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
        return await bridgehub.methods
            .l2TransactionBaseCost(parameters.chainId ?? (await this._contextL2().eth.getChainId()), parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte)
            .call();
    }
    async getDepositAllowanceParams(token, amount) {
        if ((0, utils_1.isAddressEq)(token, constants_1.LEGACY_ETH_ADDRESS)) {
            token = constants_1.ETH_ADDRESS_IN_CONTRACTS;
        }
        const baseTokenAddress = await this.getBaseToken();
        const isETHBasedChain = await this.isETHBasedChain();
        if (isETHBasedChain && (0, utils_1.isAddressEq)(token, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            throw new Error("ETH token can't be approved! The address of the token does not exist on L1.");
        }
        else if ((0, utils_1.isAddressEq)(baseTokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return [{ token, allowance: amount }];
        }
        else if ((0, utils_1.isAddressEq)(token, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return [
                {
                    token: baseTokenAddress,
                    allowance: (await this._getDepositETHOnNonETHBasedChainTx({ token, amount }))
                        .mintValue,
                },
            ];
        }
        else if ((0, utils_1.isAddressEq)(token, baseTokenAddress)) {
            return [
                {
                    token: baseTokenAddress,
                    allowance: (await this._getDepositBaseTokenOnNonETHBasedChainTx({
                        token,
                        amount,
                    })).mintValue,
                },
            ];
        }
        else {
            return [
                {
                    token: baseTokenAddress,
                    allowance: (await this._getDepositNonBaseTokenToNonETHBasedChainTx({
                        token,
                        amount,
                    })).mintValue,
                },
                {
                    token: token,
                    allowance: amount,
                },
            ];
        }
    }
    async deposit(transaction) {
        if ((0, utils_1.isAddressEq)(transaction.token, constants_1.LEGACY_ETH_ADDRESS)) {
            transaction.token = constants_1.ETH_ADDRESS_IN_CONTRACTS;
        }
        const baseTokenAddress = await this.getBaseToken();
        const isETHBasedChain = (0, utils_1.isAddressEq)(baseTokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS);
        if (isETHBasedChain && (0, utils_1.isAddressEq)(transaction.token, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return await this._depositETHToETHBasedChain(transaction);
        }
        else if ((0, utils_1.isAddressEq)(baseTokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return await this._depositTokenToETHBasedChain(transaction);
        }
        else if ((0, utils_1.isAddressEq)(transaction.token, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return await this._depositETHToNonETHBasedChain(transaction);
        }
        else if ((0, utils_1.isAddressEq)(transaction.token, baseTokenAddress)) {
            return await this._depositBaseTokenToNonETHBasedChain(transaction);
        }
        else {
            return await this._depositNonBaseTokenToNonETHBasedChain(transaction);
        }
    }
    async _depositNonBaseTokenToNonETHBasedChain(transaction) {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const baseTokenAddress = await bridgehub.methods.baseToken(chainId).call();
        const bridgeContracts = await this.getL1BridgeContracts();
        const { tx, mintValue } = await this._getDepositNonBaseTokenToNonETHBasedChainTx(transaction);
        if (transaction.approveBaseERC20) {
            const allowance = await this.getAllowanceL1(baseTokenAddress, bridgeContracts.shared.options.address);
            if (allowance < mintValue) {
                await this.approveERC20(baseTokenAddress, mintValue, {
                    bridgeAddress: bridgeContracts.shared.options.address,
                    ...transaction.approveBaseOverrides,
                });
            }
        }
        if (transaction.approveERC20) {
            const bridgeAddress = transaction.bridgeAddress
                ? transaction.bridgeAddress
                : bridgeContracts.shared.options.address;
            const allowance = await this.getAllowanceL1(transaction.token, bridgeAddress);
            if (allowance < BigInt(transaction.amount)) {
                await this.approveERC20(transaction.token, transaction.amount, {
                    bridgeAddress,
                    ...transaction.approveOverrides,
                });
            }
        }
        const baseGasLimit = await tx.estimateGas();
        const gasLimit = (0, utils_1.scaleGasLimit)(baseGasLimit);
        return this.signAndSend(tx.populateTransaction({ gasLimit }));
    }
    async _depositBaseTokenToNonETHBasedChain(transaction) {
        var _a;
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const baseTokenAddress = await bridgehub.methods.baseToken(chainId).call();
        const sharedBridge = (await this.getL1BridgeContracts()).shared.options.address;
        const { tx, mintValue } = await this._getDepositBaseTokenOnNonETHBasedChainTx(transaction);
        if (transaction.approveERC20 || transaction.approveBaseERC20) {
            const approveOverrides = transaction.approveBaseOverrides ?? transaction.approveOverrides;
            const allowance = await this.getAllowanceL1(baseTokenAddress, sharedBridge);
            if (allowance < mintValue) {
                await this.approveERC20(baseTokenAddress, mintValue, {
                    bridgeAddress: sharedBridge,
                    ...approveOverrides,
                });
            }
        }
        const baseGasLimit = await this.estimateGasRequestExecute(tx);
        const gasLimit = (0, utils_1.scaleGasLimit)(baseGasLimit);
        tx.overrides ?? (tx.overrides = {});
        (_a = tx.overrides).gasLimit ?? (_a.gasLimit = gasLimit);
        return this.requestExecute(tx);
    }
    async _depositETHToNonETHBasedChain(transaction) {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const baseTokenAddress = await bridgehub.methods.baseToken(chainId).call();
        const sharedBridge = (await this.getL1BridgeContracts()).shared.options.address;
        const { tx, overrides, mintValue } = await this._getDepositETHOnNonETHBasedChainTx(transaction);
        if (transaction.approveBaseERC20) {
            const allowance = await this.getAllowanceL1(baseTokenAddress, sharedBridge);
            if (allowance < mintValue) {
                await this.approveERC20(baseTokenAddress, mintValue, {
                    bridgeAddress: sharedBridge,
                    ...transaction.approveBaseOverrides,
                });
            }
        }
        const baseGasLimit = await tx.estimateGas({
            value: overrides.value ? web3Utils.toHex(overrides.value) : undefined,
        });
        const gasLimit = (0, utils_1.scaleGasLimit)(baseGasLimit);
        overrides.gasLimit ?? (overrides.gasLimit = gasLimit);
        return this.signAndSend(tx.populateTransaction(overrides));
    }
    async _depositTokenToETHBasedChain(transaction) {
        const bridgeContracts = await this.getL1BridgeContracts();
        const { tx, overrides } = await this._getDepositTokenOnETHBasedChainTx(transaction);
        if (transaction.approveERC20) {
            const proposedBridge = bridgeContracts.shared.options.address;
            const bridgeAddress = transaction.bridgeAddress
                ? transaction.bridgeAddress
                : proposedBridge;
            const allowance = await this.getAllowanceL1(transaction.token, bridgeAddress);
            if (allowance < BigInt(transaction.amount)) {
                await this.approveERC20(transaction.token, transaction.amount, {
                    bridgeAddress,
                    ...transaction.approveOverrides,
                });
            }
        }
        const baseGasLimit = await tx.estimateGas(overrides);
        const gasLimit = (0, utils_1.scaleGasLimit)(baseGasLimit);
        overrides.gasLimit ?? (overrides.gasLimit = gasLimit);
        return this.signAndSend(tx.populateTransaction(overrides));
    }
    async _depositETHToETHBasedChain(transaction) {
        var _a;
        const tx = await this._getDepositETHOnETHBasedChainTx(transaction);
        const baseGasLimit = await this.estimateGasRequestExecute(tx);
        const gasLimit = (0, utils_1.scaleGasLimit)(baseGasLimit);
        tx.overrides ?? (tx.overrides = {});
        (_a = tx.overrides).gasLimit ?? (_a.gasLimit = gasLimit);
        return this.requestExecute(tx);
    }
    async estimateGasDeposit(transaction) {
        if ((0, utils_1.isAddressEq)(transaction.token, constants_1.LEGACY_ETH_ADDRESS)) {
            transaction.token = constants_1.ETH_ADDRESS_IN_CONTRACTS;
        }
        const tx = await this.getDepositTx(transaction);
        let baseGasLimit;
        if (tx.token && (0, utils_1.isAddressEq)(tx.token, await this.getBaseToken())) {
            baseGasLimit = await this.estimateGasRequestExecute(tx);
        }
        else {
            baseGasLimit = await this._contextL1().eth.estimateGas(tx);
        }
        return (0, utils_1.scaleGasLimit)(baseGasLimit);
    }
    async getDepositTx(transaction) {
        if ((0, utils_1.isAddressEq)(transaction.token, constants_1.LEGACY_ETH_ADDRESS)) {
            transaction.token = constants_1.ETH_ADDRESS_IN_CONTRACTS;
        }
        const baseTokenAddress = await this.getBaseToken();
        const isETHBasedChain = (0, utils_1.isAddressEq)(baseTokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS);
        if (isETHBasedChain && (0, utils_1.isAddressEq)(transaction.token, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return await this._getDepositETHOnETHBasedChainTx(transaction);
        }
        else if (isETHBasedChain) {
            return await this._getDepositTokenOnETHBasedChainTx(transaction);
        }
        else if ((0, utils_1.isAddressEq)(transaction.token, constants_1.ETH_ADDRESS_IN_CONTRACTS)) {
            return (await this._getDepositETHOnNonETHBasedChainTx(transaction)).tx;
        }
        else if ((0, utils_1.isAddressEq)(transaction.token, baseTokenAddress)) {
            return (await this._getDepositBaseTokenOnNonETHBasedChainTx(transaction)).tx;
        }
        else {
            return (await this._getDepositNonBaseTokenToNonETHBasedChainTx(transaction)).tx;
        }
    }
    async _getDepositNonBaseTokenToNonETHBasedChainTx(transaction) {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const bridgeContracts = await this.getL1BridgeContracts();
        const tx = await this._getDepositTxWithDefaults(transaction);
        const { token, operatorTip, amount, overrides, l2GasLimit, to, refundRecipient, gasPerPubdataByte, } = tx;
        const baseCost = await this.getBaseCost({
            gasPrice: overrides.maxFeePerGas || overrides.gasPrice,
            gasLimit: l2GasLimit,
            gasPerPubdataByte: gasPerPubdataByte,
            chainId,
        });
        const mintValue = web3Utils.toBigInt(baseCost) + web3Utils.toBigInt(operatorTip);
        await (0, utils_1.checkBaseCost)(baseCost, mintValue);
        overrides.value ?? (overrides.value = 0);
        return {
            tx: bridgehub.methods.requestL2TransactionTwoBridges({
                chainId: chainId,
                mintValue,
                l2Value: 0,
                l2GasLimit: l2GasLimit,
                l2GasPerPubdataByteLimit: gasPerPubdataByte,
                refundRecipient: refundRecipient ?? types_1.ZeroAddress,
                secondBridgeAddress: bridgeContracts.shared.options.address,
                secondBridgeValue: 0,
                secondBridgeCalldata: Web3EthAbi.encodeParameters(['address', 'uint256', 'address'], [token, amount, to]),
            }),
            overrides,
            mintValue: mintValue,
        };
    }
    async _getDepositBaseTokenOnNonETHBasedChainTx(transaction) {
        const tx = await this._getDepositTxWithDefaults(transaction);
        const { operatorTip, amount, to, overrides, l2GasLimit, gasPerPubdataByte } = tx;
        const baseCost = await this.getBaseCost({
            gasPrice: overrides.maxFeePerGas || overrides.gasPrice,
            gasLimit: l2GasLimit,
            gasPerPubdataByte: gasPerPubdataByte,
        });
        tx.overrides.value = 0;
        return {
            tx: {
                contractAddress: to,
                calldata: '0x',
                mintValue: (0, web3_utils_1.toBigInt)(baseCost) + BigInt(operatorTip) + BigInt(amount),
                l2Value: amount,
                ...tx,
            },
            mintValue: (0, web3_utils_1.toBigInt)(baseCost) + BigInt(operatorTip) + BigInt(amount),
        };
    }
    async _getDepositETHOnNonETHBasedChainTx(transaction) {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const sharedBridge = (await this.getL1BridgeContracts()).shared.options.address;
        const tx = await this._getDepositTxWithDefaults(transaction);
        const { operatorTip, amount, overrides, l2GasLimit, to, refundRecipient, gasPerPubdataByte, } = tx;
        const baseCost = await this.getBaseCost({
            gasPrice: overrides.maxFeePerGas || overrides.gasPrice,
            gasLimit: l2GasLimit,
            chainId: chainId,
            gasPerPubdataByte: gasPerPubdataByte,
        });
        overrides.value ?? (overrides.value = amount);
        const mintValue = web3Utils.toBigInt(baseCost) + web3Utils.toBigInt(operatorTip);
        await (0, utils_1.checkBaseCost)(baseCost, mintValue);
        return {
            tx: bridgehub.methods.requestL2TransactionTwoBridges({
                chainId,
                mintValue,
                l2Value: 0,
                l2GasLimit: l2GasLimit,
                l2GasPerPubdataByteLimit: gasPerPubdataByte,
                refundRecipient: refundRecipient ?? types_1.ZeroAddress,
                secondBridgeAddress: sharedBridge,
                secondBridgeValue: amount,
                secondBridgeCalldata: Web3EthAbi.encodeParameters(['address', 'uint256', 'address'], [constants_1.ETH_ADDRESS_IN_CONTRACTS, 0, to]),
            }),
            overrides,
            mintValue: mintValue,
        };
    }
    async _getDepositTokenOnETHBasedChainTx(transaction) {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const tx = await this._getDepositTxWithDefaults(transaction);
        const { token, operatorTip, amount, overrides, l2GasLimit, to, refundRecipient, gasPerPubdataByte, } = tx;
        const baseCost = await this.getBaseCost({
            gasPrice: overrides.maxFeePerGas || overrides.gasPrice,
            gasLimit: l2GasLimit,
            gasPerPubdataByte,
            chainId,
        });
        const mintValue = web3Utils.toBigInt(baseCost) + web3Utils.toBigInt(operatorTip);
        overrides.value ?? (overrides.value = mintValue);
        await (0, utils_1.checkBaseCost)(baseCost, mintValue);
        let secondBridgeAddress;
        let secondBridgeCalldata;
        if (tx.bridgeAddress) {
            secondBridgeAddress = tx.bridgeAddress;
            secondBridgeCalldata = await (0, utils_1.getERC20DefaultBridgeData)(transaction.token, this._contextL1());
        }
        else {
            secondBridgeAddress = (await this.getL1BridgeContracts()).shared.options
                .address;
            secondBridgeCalldata = Web3EthAbi.encodeParameters(['address', 'uint256', 'address'], [token, amount, to]);
        }
        return {
            tx: bridgehub.methods.requestL2TransactionTwoBridges({
                chainId,
                mintValue,
                l2Value: 0,
                l2GasLimit,
                l2GasPerPubdataByteLimit: gasPerPubdataByte,
                refundRecipient: refundRecipient ?? types_1.ZeroAddress,
                secondBridgeAddress,
                secondBridgeValue: 0,
                secondBridgeCalldata,
            }),
            overrides,
        };
    }
    async _getDepositETHOnETHBasedChainTx(transaction) {
        const tx = await this._getDepositTxWithDefaults(transaction);
        const { operatorTip, amount, overrides, l2GasLimit, gasPerPubdataByte, to } = tx;
        const baseCost = await this.getBaseCost({
            gasPrice: overrides.maxFeePerGas || overrides.gasPrice,
            gasLimit: l2GasLimit,
            gasPerPubdataByte,
        });
        overrides.value ?? (overrides.value = web3Utils.toBigInt(baseCost) +
            web3Utils.toBigInt(operatorTip) +
            web3Utils.toBigInt(amount));
        return {
            contractAddress: to,
            calldata: '0x',
            mintValue: overrides.value,
            l2Value: amount,
            ...tx,
        };
    }
    async _getDepositTxWithDefaults(transaction) {
        const { ...tx } = transaction;
        tx.to = tx.to ?? this.getAddress();
        tx.operatorTip ?? (tx.operatorTip = 0);
        tx.overrides ?? (tx.overrides = {});
        tx.overrides.from = this.getAddress();
        tx.gasPerPubdataByte ?? (tx.gasPerPubdataByte = constants_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
        tx.l2GasLimit ?? (tx.l2GasLimit = await this._getL2GasLimit(tx));
        await insertGasPrice(this._contextL1(), tx.overrides);
        return tx;
    }
    async _getL2GasLimit(transaction) {
        if (transaction.bridgeAddress) {
            return await this._getL2GasLimitFromCustomBridge(transaction);
        }
        else {
            return await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._contextL1(), this._contextL2(), transaction.token, transaction.amount, transaction.to, this.getAddress(), transaction.gasPerPubdataByte);
        }
    }
    async _getL2GasLimitFromCustomBridge(transaction) {
        const customBridgeData = transaction.customBridgeData ??
            (await (0, utils_1.getERC20DefaultBridgeData)(transaction.token, this._contextL1()));
        const bridge = new (this._contextL1().eth.Contract)(IL1Bridge_1.IL1BridgeABI, transaction.bridgeAddress);
        const chainId = (await this._contextL2().eth.getChainId());
        const l2Address = await bridge.methods.l2BridgeAddress(chainId).call();
        return await (0, utils_1.estimateCustomBridgeDepositL2Gas)(this._contextL2(), transaction.bridgeAddress, l2Address, transaction.token, transaction.amount, transaction.to, customBridgeData, this.getAddress(), transaction.gasPerPubdataByte);
    }
    async getFullRequiredDepositFee(transaction) {
        var _a, _b;
        if ((0, utils_1.isAddressEq)(transaction.token, constants_1.LEGACY_ETH_ADDRESS)) {
            transaction.token = constants_1.ETH_ADDRESS_IN_CONTRACTS;
        }
        const dummyAmount = 1n;
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const baseTokenAddress = await this.getBaseToken();
        const isETHBasedChain = (0, utils_1.isAddressEq)(baseTokenAddress, constants_1.ETH_ADDRESS_IN_CONTRACTS);
        const tx = await this._getDepositTxWithDefaults({
            ...transaction,
            amount: dummyAmount,
        });
        const gasPriceForEstimation = tx.overrides.maxFeePerGas || tx.overrides.gasPrice;
        const baseCost = await bridgehub.methods
            .l2TransactionBaseCost(chainId, gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte)
            .call();
        if (isETHBasedChain) {
            const selfBalanceETH = await this.getBalanceL1();
            if ((0, web3_utils_1.toBigInt)(baseCost) >= (0, web3_utils_1.toBigInt)(selfBalanceETH) + (0, web3_utils_1.toBigInt)(dummyAmount)) {
                const recommendedL1GasLimit = (0, utils_1.isAddressEq)(tx.token, constants_1.LEGACY_ETH_ADDRESS)
                    ? constants_1.L1_RECOMMENDED_MIN_ETH_DEPOSIT_GAS_LIMIT
                    : constants_1.L1_RECOMMENDED_MIN_ERC20_DEPOSIT_GAS_LIMIT;
                const recommendedETHBalance = BigInt(recommendedL1GasLimit) * BigInt(gasPriceForEstimation) +
                    (0, web3_utils_1.toBigInt)(baseCost);
                const formattedRecommendedBalance = web3Utils.fromWei(recommendedETHBalance, 'ether');
                throw new Error(`Not enough balance for deposit! Under the provided gas price, the recommended balance to perform a deposit is ${formattedRecommendedBalance} ETH`);
            }
            if (!(0, utils_1.isAddressEq)(tx.token, constants_1.ETH_ADDRESS_IN_CONTRACTS) &&
                (await this.getAllowanceL1(tx.token, tx.bridgeAddress)) < dummyAmount) {
                throw new Error('Not enough allowance to cover the deposit!');
            }
        }
        else {
            const mintValue = (0, web3_utils_1.toBigInt)(baseCost) + BigInt(tx.operatorTip);
            if ((await this.getAllowanceL1(baseTokenAddress)) < mintValue) {
                throw new Error('Not enough base token allowance to cover the deposit!');
            }
            if ((0, utils_1.isAddressEq)(tx.token, constants_1.ETH_ADDRESS_IN_CONTRACTS) ||
                (0, utils_1.isAddressEq)(tx.token, baseTokenAddress)) {
                (_a = tx.overrides).value ?? (_a.value = tx.amount);
            }
            else {
                (_b = tx.overrides).value ?? (_b.value = 0);
                if ((await this.getAllowanceL1(tx.token)) < dummyAmount) {
                    throw new Error('Not enough token allowance to cover the deposit!');
                }
            }
        }
        const estimationOverrides = { ...tx.overrides };
        delete estimationOverrides.gasPrice;
        delete estimationOverrides.maxFeePerGas;
        delete estimationOverrides.maxPriorityFeePerGas;
        const l1GasLimit = await this.estimateGasDeposit({
            ...tx,
            amount: dummyAmount,
            overrides: estimationOverrides,
            l2GasLimit: tx.l2GasLimit,
        });
        const fullCost = {
            baseCost: (0, web3_utils_1.toBigInt)(baseCost),
            l1GasLimit,
            l2GasLimit: BigInt(tx.l2GasLimit),
        };
        if (tx.overrides.gasPrice) {
            fullCost.gasPrice = BigInt(tx.overrides.gasPrice);
        }
        else {
            fullCost.maxFeePerGas = BigInt(tx.overrides.maxFeePerGas);
            fullCost.maxPriorityFeePerGas = BigInt(tx.overrides.maxPriorityFeePerGas);
        }
        return fullCost;
    }
    async getPriorityOpConfirmation(txHash, index = 0) {
        return this._contextL2().getPriorityOpConfirmation(txHash, index);
    }
    async _getWithdrawalLog(withdrawalHash, index = 0) {
        const hash = web3Utils.toHex(withdrawalHash);
        const receipt = await this._contextL2().getZKTransactionReceipt(hash);
        if (!receipt) {
            return {
                log: {},
                l1BatchTxId: 0n,
            };
        }
        const topic = (0, utils_1.id)('L1MessageSent(address,bytes32,bytes)');
        const log = (receipt?.logs || []).filter(l => (0, utils_1.isAddressEq)(String(l?.address), constants_1.L1_MESSENGER_ADDRESS) &&
            l?.topics &&
            String(l?.topics[0]) === topic)[index];
        return {
            log,
            l1BatchTxId: receipt.l1BatchTxIndex,
        };
    }
    async _getWithdrawalL2ToL1Log(withdrawalHash, index = 0) {
        const hash = web3Utils.toHex(withdrawalHash);
        const receipt = await this._contextL2().getZKTransactionReceipt(hash);
        if (!receipt) {
            return {};
        }
        const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([, log]) => (0, utils_1.isAddressEq)(log.sender, constants_1.L1_MESSENGER_ADDRESS));
        const [l2ToL1LogIndex, l2ToL1Log] = messages[index];
        return {
            l2ToL1LogIndex,
            l2ToL1Log,
        };
    }
    async finalizeWithdrawalParams(withdrawalHash, index = 0) {
        const { log, l1BatchTxId } = await this._getWithdrawalLog(withdrawalHash, index);
        const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
        const sender = log?.topics && (0, utils_1.dataSlice)((0, utils_1.toBytes)(log?.topics[1]), 12);
        const proof = await this._contextL2().getL2ToL1LogProof((0, web3_utils_1.toHex)(withdrawalHash), l2ToL1LogIndex);
        if (!proof) {
            throw new Error('Log proof not found!');
        }
        const message = Web3EthAbi.decodeParameters(['bytes'], log.data)[0];
        return {
            l1BatchNumber: log.l1BatchNumber,
            l2MessageIndex: Number((0, web3_utils_1.toNumber)(proof.id)),
            l2TxNumberInBlock: l1BatchTxId !== undefined ? Number((0, web3_utils_1.toNumber)(l1BatchTxId)) : null,
            message,
            sender: sender,
            proof: proof.proof,
        };
    }
    async finalizeWithdrawal(withdrawalHash, index = 0, overrides) {
        const { l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof } = await this.finalizeWithdrawalParams(withdrawalHash, index);
        const l1Contracts = await this.getL1BridgeContracts();
        const contract = new (this._contextL1().eth.Contract)(IL1Bridge_1.IL1BridgeABI, l1Contracts.shared.options.address);
        overrides = overrides ?? {};
        overrides.from ?? (overrides.from = this.getAddress());
        return (contract.methods
            .finalizeWithdrawal((await this._contextL2().eth.getChainId()), l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof)
            .send(overrides ?? {}));
    }
    async isWithdrawalFinalized(withdrawalHash, index = 0) {
        const { log } = await this._getWithdrawalLog(withdrawalHash, index);
        const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
        const sender = (0, utils_1.dataSlice)((log && log.topics && log.topics[1]), 12);
        const proof = await this._contextL2().getL2ToL1LogProof((0, web3_utils_1.toHex)(withdrawalHash), l2ToL1LogIndex);
        if (!proof) {
            throw new Error('Log proof not found!');
        }
        const chainId = await this._contextL2().eth.getChainId();
        let l1Bridge;
        if (await this._contextL2().isBaseToken(sender)) {
            l1Bridge = (await this.getL1BridgeContracts()).shared;
        }
        else {
            const l2BridgeContract = new (this._contextL2().eth.Contract)(IL2Bridge_1.IL2BridgeABI, sender);
            const l1BridgeAddress = await l2BridgeContract.methods.l1Bridge().call();
            l1Bridge = new (this._contextL1().eth.Contract)(IL1SharedBridge_1.Abi, l1BridgeAddress);
        }
        return await l1Bridge.methods
            .isWithdrawalFinalized(chainId, log.l1BatchNumber, proof.id)
            .call();
    }
    async claimFailedDeposit(depositHash, overrides) {
        const receipt = await this._contextL2().getZKTransactionReceipt(web3Utils.toHex(depositHash));
        if (!receipt) {
            throw new Error('Transaction not found!');
        }
        const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex(l2ToL1log => (0, utils_1.isAddressEq)(l2ToL1log.sender, constants_1.BOOTLOADER_FORMAL_ADDRESS) &&
            l2ToL1log.key === depositHash);
        const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];
        if (successL2ToL1Log.value !== types_1.ZeroHash) {
            throw new Error('Cannot claim successful deposit!');
        }
        const tx = await this._contextL2().eth.getTransaction(web3Utils.toHex(depositHash));
        const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);
        const l2BridgeAddress = receipt.to;
        if (!l2BridgeAddress) {
            throw new Error('L2 bridge address not found!');
        }
        const l1Bridge = new (this._contextL1().eth.Contract)(IL1Bridge_1.IL1BridgeABI, l1BridgeAddress);
        const l2Bridge = new Web3.Contract(IL2Bridge_1.IL2BridgeABI, l1BridgeAddress);
        l2Bridge.setProvider(this._contextL2().provider);
        const calldata = l2Bridge.methods
            .finalizeDeposit()
            .decodeData(web3Utils.toHex(String(tx.data)));
        const proof = await this._contextL2().getL2ToL1LogProof(web3Utils.toHex(depositHash), successL2ToL1LogIndex);
        if (!proof) {
            throw new Error('Log proof not found!');
        }
        return (l1Bridge.methods
            .claimFailedDeposit((await this._contextL2().eth.getChainId()), calldata[0], calldata[2], calldata[3], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof)
            .send(overrides ?? {}));
    }
    async requestExecute(transaction) {
        const tx = await this.getRequestExecuteTx(transaction);
        return this.signAndSend(tx);
    }
    async signAndSend(tx, _context) {
        const context = _context || this._contextL1();
        const populated = await context.populateTransaction(tx);
        const signed = await context.signTransaction(populated);
        return (0, utils_1.getPriorityOpResponse)(context, context.sendRawTransaction(signed), this._contextL2());
    }
    async signTransaction(tx) {
        return this._contextL1().signTransaction(tx);
    }
    async sendRawTransaction(signedTx) {
        return this._contextL1().sendRawTransaction(signedTx);
    }
    async estimateGasRequestExecute(transaction) {
        const { method, overrides } = await this.getRequestExecuteContractMethod(transaction);
        delete overrides.gasPrice;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        return method.estimateGas(overrides);
    }
    async getRequestExecuteAllowanceParams(transaction) {
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const isETHBaseToken = (0, utils_1.isAddressEq)(await bridgehub.methods.baseToken(chainId).call(), constants_1.ETH_ADDRESS_IN_CONTRACTS);
        if (isETHBaseToken) {
            throw new Error("ETH token can't be approved! The address of the token does not exist on L1.");
        }
        const { ...tx } = transaction;
        tx.l2Value ?? (tx.l2Value = 0n);
        tx.operatorTip ?? (tx.operatorTip = 0n);
        tx.factoryDeps ?? (tx.factoryDeps = []);
        tx.overrides ?? (tx.overrides = {});
        tx.gasPerPubdataByte ?? (tx.gasPerPubdataByte = constants_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
        tx.refundRecipient ?? (tx.refundRecipient = this.getAddress());
        tx.l2GasLimit ?? (tx.l2GasLimit = await this._contextL2().estimateL1ToL2Execute(transaction));
        const { l2Value, l2GasLimit, operatorTip, overrides, gasPerPubdataByte } = tx;
        await insertGasPrice(this._contextL1(), overrides);
        const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
        const baseCost = await this.getBaseCost({
            gasPrice: gasPriceForEstimation,
            gasPerPubdataByte,
            gasLimit: l2GasLimit,
        });
        return {
            token: await this.getBaseToken(),
            allowance: baseCost + BigInt(operatorTip) + BigInt(l2Value),
        };
    }
    async getRequestExecuteContractMethod(transaction) {
        var _a;
        const bridgehub = await this.getBridgehubContract();
        const chainId = await this._contextL2().eth.getChainId();
        const isETHBaseToken = (0, utils_1.isAddressEq)(await bridgehub.methods.baseToken(chainId).call(), constants_1.ETH_ADDRESS_IN_CONTRACTS);
        const { ...tx } = transaction;
        tx.l2Value ?? (tx.l2Value = 0);
        tx.mintValue ?? (tx.mintValue = 0);
        tx.operatorTip ?? (tx.operatorTip = 0);
        tx.factoryDeps ?? (tx.factoryDeps = []);
        tx.overrides ?? (tx.overrides = {});
        (_a = tx.overrides).from ?? (_a.from = this.getAddress());
        tx.gasPerPubdataByte ?? (tx.gasPerPubdataByte = constants_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
        tx.refundRecipient ?? (tx.refundRecipient = this.getAddress());
        tx.l2GasLimit ?? (tx.l2GasLimit = await this._contextL2().estimateL1ToL2Execute(transaction));
        const { contractAddress, mintValue, l2Value, calldata, l2GasLimit, factoryDeps, operatorTip, overrides, gasPerPubdataByte, refundRecipient, } = tx;
        await insertGasPrice(this._contextL1(), overrides);
        const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
        const baseCost = await this.getBaseCost({
            gasPrice: gasPriceForEstimation,
            gasPerPubdataByte,
            gasLimit: l2GasLimit,
        });
        const l2Costs = baseCost + BigInt(operatorTip) + BigInt(l2Value);
        let providedValue = isETHBaseToken ? overrides.value : mintValue;
        if (providedValue === undefined || providedValue === null || BigInt(providedValue) === 0n) {
            providedValue = l2Costs;
            if (isETHBaseToken)
                overrides.value = providedValue;
        }
        await (0, utils_1.checkBaseCost)(baseCost, providedValue);
        const method = bridgehub.methods.requestL2TransactionDirect({
            chainId,
            mintValue: providedValue,
            l2Contract: contractAddress,
            l2Value: l2Value,
            l2Calldata: calldata,
            l2GasLimit: l2GasLimit,
            l2GasPerPubdataByteLimit: constants_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT,
            factoryDeps: factoryDeps,
            refundRecipient: refundRecipient,
        });
        return { method, overrides };
    }
    async getRequestExecuteTx(transaction) {
        const { method, overrides } = await this.getRequestExecuteContractMethod(transaction);
        return method.populateTransaction(overrides);
    }
    async populateTransaction(tx) {
        tx.from = this.getAddress();
        if ((!tx.type || (tx.type && (0, web3_utils_1.toHex)(tx.type) !== (0, web3_utils_1.toHex)(constants_1.EIP712_TX_TYPE))) &&
            !tx.customData) {
            return this._contextL1().populateTransaction(tx);
        }
        const populated = (await this._contextL1().populateTransaction(tx));
        populated.type = constants_1.EIP712_TX_TYPE;
        populated.value ?? (populated.value = 0);
        populated.data ?? (populated.data = '0x');
        return populated;
    }
    getAddress() {
        throw new Error('Must be implemented by the derived class!');
    }
}
exports.AdapterL1 = AdapterL1;
class AdapterL2 {
    _contextL2() {
        throw new Error('Must be implemented by the derived class!');
    }
    async _eip712Signer() {
        throw new Error('Must be implemented by the derived class!');
    }
    async getBalance(token, blockTag = 'committed') {
        return await this._contextL2().getBalance(this.getAddress(), blockTag, token);
    }
    async getAllBalances() {
        return this._contextL2().getAllAccountBalances(this.getAddress());
    }
    async getDeploymentNonce() {
        const contract = new Web3.Contract(INonceHolder_1.INonceHolderABI, constants_1.NONCE_HOLDER_ADDRESS);
        contract.setProvider(this._contextL2().provider);
        return contract.methods.getDeploymentNonce(this.getAddress()).call();
    }
    async getL2BridgeContracts() {
        const addresses = await this._contextL2().getDefaultBridgeAddresses();
        const erc20 = new Web3.Contract(IL2Bridge_1.IL2BridgeABI, addresses.erc20L2);
        const weth = new Web3.Contract(IL2Bridge_1.IL2BridgeABI, addresses.wethL2);
        const shared = new Web3.Contract(IL2Bridge_1.IL2BridgeABI, addresses.sharedL2);
        erc20.setProvider(this._contextL2().provider);
        weth.setProvider(this._contextL2().provider);
        shared.setProvider(this._contextL2().provider);
        return {
            erc20,
            weth,
            shared,
        };
    }
    async withdraw(transaction) {
        const tx = await this._contextL2().getWithdrawTx({
            ...transaction,
            from: this.getAddress(),
        });
        const populated = await this.populateTransaction(tx);
        const signed = await this.signTransaction(populated);
        return (0, utils_1.getPriorityOpResponse)(this._contextL2(), this.sendRawTransaction(signed), this._contextL2());
    }
    async signTransaction(tx) {
        return this._contextL2().signTransaction(tx);
    }
    async sendRawTransaction(signedTx) {
        return this._contextL2().sendRawTransaction(signedTx);
    }
    async transferTx(transaction) {
        return this._contextL2().getTransferTx({
            from: this.getAddress(),
            ...transaction,
        });
    }
    getAddress() {
        throw new Error('Must be implemented by the derived class!');
    }
    async populateTransaction(tx) {
        tx.from = this.getAddress();
        if ((!tx.type || (tx.type && (0, web3_utils_1.toHex)(tx.type) !== (0, web3_utils_1.toHex)(constants_1.EIP712_TX_TYPE))) &&
            !tx.customData) {
            return this._contextL2().populateTransaction(tx);
        }
        const populated = (await this._contextL2().populateTransaction(tx));
        populated.type = constants_1.EIP712_TX_TYPE;
        populated.value ?? (populated.value = 0);
        populated.data ?? (populated.data = '0x');
        return populated;
    }
}
exports.AdapterL2 = AdapterL2;
async function insertGasPrice(l1Provider, overrides) {
    if (!overrides.gasPrice && !overrides.maxFeePerGas) {
        const l1FeeData = await l1Provider.eth.calculateFeeData();
        const baseFee = BigInt(l1FeeData.maxFeePerGas ? getBaseCostFromFeeData(l1FeeData) : l1FeeData.gasPrice);
        if (!baseFee) {
            throw new Error('Failed to calculate base fee!');
        }
        overrides.maxFeePerGas =
            (baseFee * 3n) / 2n + (BigInt(l1FeeData.maxPriorityFeePerGas) ?? 0n);
        overrides.maxPriorityFeePerGas =
            l1FeeData.maxPriorityFeePerGas && (0, web3_utils_1.toHex)(l1FeeData.maxPriorityFeePerGas);
    }
}
function getBaseCostFromFeeData(feeData) {
    const maxFeePerGas = feeData.maxFeePerGas;
    const maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
    return (BigInt(maxFeePerGas) - BigInt(maxPriorityFeePerGas)) / 2n;
}
//# sourceMappingURL=adapters.js.map
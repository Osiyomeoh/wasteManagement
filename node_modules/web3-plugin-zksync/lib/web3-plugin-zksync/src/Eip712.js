"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIP712Transaction = exports.EIP712Signer = exports.EIP712 = void 0;
const web3_utils_1 = require("web3-utils");
const web3Abi = __importStar(require("web3-eth-abi"));
const web3Utils = __importStar(require("web3-utils"));
const web3_eth_accounts_1 = require("web3-eth-accounts");
const rlp_1 = require("@ethereumjs/rlp");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
function handleAddress(value) {
    if (!value) {
        return null;
    }
    const hexValue = (0, web3_utils_1.bytesToHex)(value);
    if (hexValue === '0x') {
        return null;
    }
    return web3Utils.toChecksumAddress(hexValue);
}
function handleNumber(value) {
    if (!value) {
        return 0n;
    }
    const hexValue = (0, web3_utils_1.bytesToHex)(value);
    if (hexValue === '0x') {
        return 0n;
    }
    return (0, web3_utils_1.toBigInt)(hexValue);
}
function arrayToPaymasterParams(arr) {
    if (arr.length === 0) {
        return undefined;
    }
    if (arr.length !== 2) {
        throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}!`);
    }
    return {
        paymaster: web3Utils.toChecksumAddress((0, web3_utils_1.toHex)(arr[0])),
        paymasterInput: web3Utils.bytesToUint8Array((0, web3_utils_1.toHex)(arr[1])),
    };
}
class EIP712 {
    static getSignInput(transaction) {
        const maxFeePerGas = (0, web3_utils_1.toBigInt)(transaction.maxFeePerGas || transaction.gasPrice || 0n);
        const maxPriorityFeePerGas = (0, web3_utils_1.toBigInt)(transaction.maxPriorityFeePerGas || maxFeePerGas);
        const gasPerPubdataByteLimit = transaction.customData?.gasPerPubdata || constants_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        return {
            txType: transaction.type || constants_1.EIP712_TX_TYPE,
            from: transaction.from
                ? typeof transaction.from === 'string'
                    ? transaction.from
                    : (0, web3_utils_1.toHex)(transaction.from)
                : undefined,
            to: transaction.to
                ? typeof transaction.to === 'string'
                    ? transaction.to
                    : (0, web3_utils_1.toHex)(transaction.to)
                : undefined,
            gasLimit: transaction.gasLimit ? (0, web3_utils_1.toBigInt)(transaction.gasLimit) : 0n,
            gasPerPubdataByteLimit: gasPerPubdataByteLimit,
            maxFeePerGas,
            maxPriorityFeePerGas,
            paymaster: transaction.customData?.paymasterParams?.paymaster || constants_1.ZERO_ADDRESS,
            nonce: transaction.nonce ? (0, web3_utils_1.toBigInt)(transaction.nonce) : 0,
            value: transaction.value ? (0, web3_utils_1.toBigInt)(transaction.value) : 0n,
            data: transaction.data ? (0, web3_utils_1.toHex)(transaction.data) : '0x',
            factoryDeps: transaction.customData?.factoryDeps?.map((dep) => (0, utils_1.hashBytecode)(dep)) || [],
            paymasterInput: transaction.customData?.paymasterParams?.paymasterInput || '0x',
            customData: transaction.customData && Object.keys(transaction.customData).length > 0
                ? transaction.customData
                : undefined,
        };
    }
    static txTypedData(transaction) {
        return {
            types: constants_1.EIP712_TYPES,
            primaryType: 'Transaction',
            domain: {
                name: 'zkSync',
                version: '2',
                chainId: Number(transaction.chainId),
            },
            message: EIP712.getSignInput(transaction),
        };
    }
    static txHash(transaction, ethSignature) {
        const bytes = [];
        const typedDataStruct = EIP712.txTypedData(transaction);
        bytes.push(web3Abi.getEncodedEip712Data(typedDataStruct, true));
        bytes.push(web3Utils.keccak256(EIP712.getSignature(typedDataStruct.message, ethSignature)));
        return web3Utils.keccak256((0, utils_1.concat)(bytes));
    }
    static fromSerializedTx(payload) {
        const bytes = web3Utils.bytesToUint8Array(payload);
        const raw = rlp_1.RLP.decode(bytes.slice(1));
        const transaction = {
            type: constants_1.EIP712_TX_TYPE,
            nonce: handleNumber(raw[0]),
            maxPriorityFeePerGas: handleNumber(raw[1]),
            maxFeePerGas: handleNumber(raw[2]),
            gasLimit: handleNumber(raw[3]),
            to: handleAddress(raw[4]),
            value: handleNumber(raw[5]),
            data: (0, web3_utils_1.bytesToHex)(raw[6]),
            chainId: handleNumber(raw[10]),
            from: handleAddress(raw[11]),
            customData: {
                gasPerPubdata: handleNumber(raw[12]),
                factoryDeps: raw[13],
                customSignature: (0, web3_utils_1.bytesToHex)(raw[14]),
                paymasterParams: arrayToPaymasterParams(raw[15]),
            },
        };
        const ethSignature = {
            v: Number(handleNumber(raw[7])),
            r: raw[8],
            s: raw[9],
        };
        if ((web3Utils.toHex(ethSignature.r) === '0x' ||
            web3Utils.toHex(ethSignature.s) === '0x') &&
            !transaction.customData?.customSignature) {
            return transaction;
        }
        if (ethSignature.v !== 0 &&
            ethSignature.v !== 1 &&
            !transaction.customData?.customSignature) {
            throw new Error('Failed to parse signature!');
        }
        if (!transaction.customData?.customSignature) {
            transaction.signature = new utils_1.SignatureObject(ethSignature).toString();
        }
        transaction.hash = EIP712.txHash(transaction, ethSignature);
        return transaction;
    }
    static getSignature(transaction, ethSignature) {
        if (transaction?.customData?.customSignature &&
            transaction.customData.customSignature.length) {
            return web3Utils.bytesToUint8Array(transaction.customData.customSignature);
        }
        if (!ethSignature) {
            throw new Error('No signature provided!');
        }
        const r = web3Utils.bytesToUint8Array(web3Utils.padLeft(web3Utils.toHex(ethSignature.r), 32 * 2));
        const s = web3Utils.bytesToUint8Array(web3Utils.padLeft(web3Utils.toHex(ethSignature.s), 32 * 2));
        const v = ethSignature.v;
        return new Uint8Array([...r, ...s, v]);
    }
    static raw(transaction, signature) {
        if (!transaction.chainId) {
            throw Error("Transaction chainId isn't set!");
        }
        if (!transaction.from) {
            throw new Error('Explicitly providing `from` field is required for EIP712 transactions!');
        }
        const from = transaction.from;
        const meta = transaction.customData ?? {};
        const maxFeePerGas = (0, web3_utils_1.toHex)(transaction.maxFeePerGas || transaction.gasPrice || 0);
        const maxPriorityFeePerGas = (0, web3_utils_1.toHex)(transaction.maxPriorityFeePerGas || maxFeePerGas);
        let gasLimitBytes = new Uint8Array();
        if (transaction.gasLimit && (0, web3_utils_1.toHex)(transaction.gasLimit) !== '0x0') {
            gasLimitBytes = (0, utils_1.toBytes)(transaction.gasLimit);
        }
        const nonce = (0, web3_utils_1.toBigInt)(transaction.nonce || 0);
        const fields = [
            nonce === 0n ? new Uint8Array() : (0, web3_eth_accounts_1.bigIntToUint8Array)(nonce),
            !maxPriorityFeePerGas || maxPriorityFeePerGas === '0x0'
                ? new Uint8Array()
                : (0, utils_1.toBytes)(maxPriorityFeePerGas),
            !maxFeePerGas || maxFeePerGas === '0x0' ? new Uint8Array() : (0, utils_1.toBytes)(maxFeePerGas),
            gasLimitBytes,
            transaction.to ? web3Utils.toChecksumAddress((0, web3_utils_1.toHex)(transaction.to)) : '0x',
            (0, web3_utils_1.toHex)(transaction.value || 0) === '0x0'
                ? new Uint8Array()
                : (0, web3_utils_1.toHex)(transaction.value || 0),
            (0, web3_utils_1.toHex)(transaction.data || '0x'),
        ];
        if (signature) {
            const signatureObject = new utils_1.SignatureObject(signature);
            fields.push((0, web3_utils_1.toHex)(Number(signatureObject.v) === 27 ? 0 : 1));
            fields.push((0, web3_utils_1.toHex)(signatureObject.r));
            fields.push((0, web3_utils_1.toHex)(signatureObject.s));
        }
        else {
            fields.push((0, web3_utils_1.toHex)(transaction.chainId));
            fields.push('0x');
            fields.push('0x');
        }
        fields.push((0, web3_utils_1.toHex)(transaction.chainId));
        fields.push(web3Utils.toChecksumAddress(from));
        fields.push((0, web3_utils_1.toHex)(meta.gasPerPubdata || constants_1.DEFAULT_GAS_PER_PUBDATA_LIMIT));
        fields.push((meta.factoryDeps ?? []).map(dep => web3Utils.toHex(dep)));
        if (meta.customSignature &&
            web3Utils.bytesToUint8Array(meta.customSignature).length === 0) {
            throw new Error('Empty signatures are not supported!');
        }
        fields.push(meta.customSignature || '0x');
        if (meta.paymasterParams) {
            fields.push([
                meta.paymasterParams.paymaster,
                web3Utils.toHex(meta.paymasterParams.paymasterInput),
            ]);
        }
        else {
            fields.push([]);
        }
        return fields;
    }
    static serialize(transaction, signature) {
        const fields = EIP712.raw(transaction, signature);
        return (0, utils_1.concat)([new Uint8Array([constants_1.EIP712_TX_TYPE]), rlp_1.RLP.encode(fields)]);
    }
    static sign(hash, privateKey) {
        return new EIP712Transaction({}).ecsign((0, web3_eth_accounts_1.toUint8Array)(web3Utils.keccak256(hash)), (0, web3_eth_accounts_1.toUint8Array)(privateKey));
    }
}
exports.EIP712 = EIP712;
class EIP712Signer {
    constructor(web3Account, chainId) {
        this.web3Account = web3Account;
        this.chainId = Number(web3Utils.toNumber(chainId));
        this.eip712Domain = {
            name: 'zkSync',
            version: '2',
            chainId: Number(this.chainId),
        };
    }
    async sign(tx) {
        const hash = web3Abi.getEncodedEip712Data(EIP712.txTypedData(tx), true);
        return (0, web3_eth_accounts_1.signMessageWithPrivateKey)(hash, this.web3Account.privateKey).signature;
    }
    static getSignedDigest(transaction) {
        if (!transaction.chainId) {
            throw Error("Transaction chainId isn't set!");
        }
        return web3Abi.getEncodedEip712Data(EIP712.txTypedData(transaction), true);
    }
    getDomain() {
        return this.eip712Domain;
    }
}
exports.EIP712Signer = EIP712Signer;
class EIP712Transaction extends web3_eth_accounts_1.BaseTransaction {
    constructor(txData) {
        super(txData, {});
        const { v, r, s, ...data } = txData;
        if (r && s) {
            this.signature = new utils_1.SignatureObject((0, web3_eth_accounts_1.toUint8Array)(r), (0, web3_eth_accounts_1.toUint8Array)(s), (0, web3_utils_1.toBigInt)(v));
        }
        this.txData = data;
    }
    getSignature() {
        return this.signature;
    }
    getMessageToSign(isHash = false) {
        const typedDataStruct = EIP712.txTypedData(this.txData);
        const message = web3Abi.getEncodedEip712Data(typedDataStruct, isHash);
        return web3Utils.hexToBytes(message);
    }
    _processSignature(v, r, s) {
        const signature = new utils_1.SignatureObject((0, web3_eth_accounts_1.toUint8Array)(r), (0, web3_eth_accounts_1.toUint8Array)(s), (0, web3_utils_1.toBigInt)(v));
        return new EIP712Transaction({
            ...this.txData,
            v: (0, web3_utils_1.toBigInt)(signature.v),
            r: (0, web3_utils_1.toHex)(signature.r),
            s: (0, web3_utils_1.toHex)(signature.s),
        });
    }
    ecsign(msgHash, privateKey, chainId) {
        const { s, r, v } = this._ecsign(msgHash, privateKey, chainId);
        this.signature = new utils_1.SignatureObject((0, web3_eth_accounts_1.toUint8Array)(r), (0, web3_eth_accounts_1.toUint8Array)(s), (0, web3_utils_1.toBigInt)(v));
        return this.signature;
    }
    _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
    }
    errorStr() {
        return '';
    }
    getMessageToVerifySignature() {
        return this.getMessageToSign();
    }
    getSenderPublicKey() {
        return new Uint8Array();
    }
    getUpfrontCost() {
        return 0n;
    }
    hash() {
        return (0, web3_eth_accounts_1.toUint8Array)(EIP712.txHash(this.txData));
    }
    raw() {
        return EIP712.raw(this.txData);
    }
    serialize() {
        return (0, web3_eth_accounts_1.toUint8Array)(EIP712.serialize(this.txData));
    }
    toJSON() {
        const data = EIP712.getSignInput(this.txData);
        return {
            to: data.to && (0, web3_utils_1.toHex)(data.to),
            gasLimit: (0, web3_utils_1.toHex)(data.gasLimit),
            gasPerPubdataByteLimit: data.gasPerPubdataByteLimit,
            customData: data.customData,
            maxFeePerGas: (0, web3_utils_1.toHex)(data.maxFeePerGas),
            maxPriorityFeePerGas: (0, web3_utils_1.toHex)(data.maxPriorityFeePerGas),
            paymaster: data.paymaster,
            nonce: (0, web3_utils_1.toHex)(data.nonce),
            value: (0, web3_utils_1.toHex)(data.value),
            data: (0, web3_utils_1.toHex)(data.data),
            factoryDeps: data.factoryDeps,
            paymasterInput: data.paymasterInput,
            type: (0, web3_utils_1.toHex)(data.txType),
            v: this.signature?.v ? (0, web3_utils_1.toHex)(this.signature.v) : undefined,
            r: this.signature?.r ? (0, web3_utils_1.toHex)(this.signature?.r) : undefined,
            s: this.signature?.s ? (0, web3_utils_1.toHex)(this.signature?.s) : undefined,
        };
    }
}
exports.EIP712Transaction = EIP712Transaction;
//# sourceMappingURL=Eip712.js.map
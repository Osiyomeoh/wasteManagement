"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TypedDataEncoder_instances, _TypedDataEncoder_types, _TypedDataEncoder_fullTypes, _TypedDataEncoder_encoderCache, _TypedDataEncoder_getEncoder;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedDataEncoder = void 0;
const utils_1 = require("./utils");
const web3_utils_1 = require("web3-utils");
const web3_validator_1 = require("web3-validator");
const padding = new Uint8Array(32);
padding.fill(0);
const BN__1 = BigInt(-1);
const BN_0 = BigInt(0);
const BN_1 = BigInt(1);
const BN_MAX_UINT256 = BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function hexPadRight(value) {
    const bytes = (0, utils_1.toBytes)(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return (0, utils_1.concat)([bytes, padding.slice(padOffset)]);
    }
    return (0, web3_utils_1.toHex)(bytes);
}
function toQuantity(value) {
    let result = (0, web3_utils_1.toHex)(value).substring(2);
    while (result.startsWith('0')) {
        result = result.substring(1);
    }
    if (result === '') {
        result = '0';
    }
    return '0x' + result;
}
const hexTrue = (0, web3_utils_1.padLeft)((0, web3_utils_1.toHex)(BN_1), 64);
const hexFalse = (0, web3_utils_1.padLeft)((0, web3_utils_1.toHex)(BN_0), 64);
const domainFieldTypes = {
    name: 'string',
    version: 'string',
    chainId: 'uint256',
    verifyingContract: 'address',
    salt: 'bytes32',
};
const domainFieldNames = ['name', 'version', 'chainId', 'verifyingContract', 'salt'];
function checkString(key) {
    return function (value) {
        if (typeof value !== 'string') {
            throw new Error(`invalid domain value for ${JSON.stringify(key)}. domain.${key}`);
        }
        return value;
    };
}
function zeroPad(data, length, left = true) {
    const bytes = (0, utils_1.toBytes)(data);
    if (length < bytes.length) {
        throw new Error('padding exceeds data length');
    }
    const result = new Uint8Array(length);
    result.fill(0);
    if (left) {
        result.set(bytes, length - bytes.length);
    }
    else {
        result.set(bytes, 0);
    }
    return (0, web3_utils_1.toHex)(result);
}
const domainChecks = {
    name: checkString('name'),
    version: checkString('version'),
    chainId: function (_value) {
        const value = (0, web3_utils_1.toBigInt)(_value);
        if (value < 0) {
            throw new Error(`invalid domain value for chain ID. domain.chainId`);
        }
        if (Number.isSafeInteger(value)) {
            return Number(value);
        }
        return toQuantity(value);
    },
    verifyingContract: function (value) {
        try {
            return (0, utils_1.getAddress)(value).toLowerCase();
        }
        catch (error) { }
        throw new Error('invalid domain value "verifyingContract"');
    },
    salt: function (value) {
        const bytes = (0, utils_1.toBytes)(value);
        if (bytes.length !== 32) {
            throw new Error('invalid domain value "salt"');
        }
        return (0, web3_utils_1.toHex)(bytes);
    },
};
function mask(_value, _bits) {
    const value = (0, web3_utils_1.toBigInt)(_value);
    const bits = (0, web3_utils_1.toBigInt)(_bits);
    return value & ((BN_1 << bits) - BN_1);
}
function getBaseEncoder(type) {
    {
        const match = type.match(/^(u?)int(\d+)$/);
        if (match) {
            const signed = match[1] === '';
            const width = parseInt(match[2]);
            if (!(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width))) {
                throw new Error('getBaseEncoder: invalid numeric width');
            }
            const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);
            const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;
            return function (_value) {
                const value = (0, web3_utils_1.toBigInt)(_value);
                if (!(value >= boundsLower && value <= boundsUpper)) {
                    throw new Error(`value out-of-bounds for ${type}`);
                }
                return (0, web3_utils_1.padLeft)((0, web3_utils_1.toHex)(signed ? (0, web3_utils_1.toTwosComplement)(value, 256) : value), 64);
            };
        }
    }
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (!(width !== 0 && width <= 32 && match[1] === String(width))) {
                throw new Error('getBaseEncoder: invalid bytes width');
            }
            return function (value) {
                const bytes = (0, utils_1.toBytes)(value);
                if (!(bytes.length === width)) {
                    throw new Error(`invalid length for ${type}`);
                }
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case 'address':
            return function (value) {
                return zeroPad((0, utils_1.getAddress)(value), 32);
            };
        case 'bool':
            return function (value) {
                return !value ? hexFalse : hexTrue;
            };
        case 'bytes':
            return function (value) {
                return (0, web3_utils_1.keccak256)(value);
            };
        case 'string':
            return function (value) {
                return (0, utils_1.id)(value);
            };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => type + ' ' + name).join(',')})`;
}
function splitArray(type) {
    const match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    if (match) {
        return {
            base: match[1],
            index: match[2] + match[4],
            array: {
                base: match[1],
                prefix: match[1] + match[2],
                count: match[5] ? parseInt(match[5]) : -1,
            },
        };
    }
    return { base: type };
}
class TypedDataEncoder {
    get types() {
        return JSON.parse(__classPrivateFieldGet(this, _TypedDataEncoder_types, "f"));
    }
    constructor(_types) {
        _TypedDataEncoder_instances.add(this);
        _TypedDataEncoder_types.set(this, void 0);
        _TypedDataEncoder_fullTypes.set(this, void 0);
        _TypedDataEncoder_encoderCache.set(this, void 0);
        __classPrivateFieldSet(this, _TypedDataEncoder_fullTypes, new Map(), "f");
        __classPrivateFieldSet(this, _TypedDataEncoder_encoderCache, new Map(), "f");
        const links = new Map();
        const parents = new Map();
        const subtypes = new Map();
        const types = {};
        Object.keys(_types).forEach(type => {
            types[type] = _types[type].map(({ name, type }) => {
                let { base, index } = splitArray(type);
                if (base === 'int' && !_types['int']) {
                    base = 'int256';
                }
                if (base === 'uint' && !_types['uint']) {
                    base = 'uint256';
                }
                return { name, type: base + (index || '') };
            });
            links.set(type, new Set());
            parents.set(type, []);
            subtypes.set(type, new Set());
        });
        __classPrivateFieldSet(this, _TypedDataEncoder_types, JSON.stringify(types), "f");
        for (const name in types) {
            const uniqueNames = new Set();
            for (const field of types[name]) {
                if (uniqueNames.has(field.name)) {
                    throw new Error(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`);
                }
                uniqueNames.add(field.name);
                const baseType = splitArray(field.type).base;
                if (baseType === name) {
                    throw new Error(`circular type reference to ${JSON.stringify(baseType)}`);
                }
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    continue;
                }
                if (!parents.has(baseType)) {
                    throw new Error(`unknown type ${JSON.stringify(baseType)}`);
                }
                parents.get(baseType).push(name);
                links.get(name).add(baseType);
            }
        }
        const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);
        if (primaryTypes.length === 0) {
            throw new Error('missing primary type');
        }
        if (primaryTypes.length !== 1) {
            throw new Error(`ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(', ')}`);
        }
        this.primaryType = primaryTypes[0];
        function checkCircular(type, found) {
            if (found.has(type)) {
                throw new Error(`circular type reference to ${JSON.stringify(type)}`);
            }
            found.add(type);
            for (const child of links.get(type)) {
                if (!parents.has(child)) {
                    continue;
                }
                checkCircular(child, found);
                for (const subtype of found) {
                    subtypes.get(subtype).add(child);
                }
            }
            found.delete(type);
        }
        checkCircular(this.primaryType, new Set());
        for (const [name, set] of subtypes) {
            const st = Array.from(set);
            st.sort();
            __classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, "f").set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(''));
        }
    }
    getEncoder(type) {
        let encoder = __classPrivateFieldGet(this, _TypedDataEncoder_encoderCache, "f").get(type);
        if (!encoder) {
            encoder = __classPrivateFieldGet(this, _TypedDataEncoder_instances, "m", _TypedDataEncoder_getEncoder).call(this, type);
            __classPrivateFieldGet(this, _TypedDataEncoder_encoderCache, "f").set(type, encoder);
        }
        return encoder;
    }
    encodeType(name) {
        const result = __classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, "f").get(name);
        if (!result) {
            throw new Error(`unknown type: ${JSON.stringify(name)}`);
        }
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return (0, web3_utils_1.keccak256)(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        const array = splitArray(type).array;
        if (array) {
            if (!(array.count === -1 || array.count === value.length)) {
                throw new Error(`array length mismatch; expected length ${array.count}`);
            }
            return value.map((v) => this._visit(array.prefix, v, callback));
        }
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        throw new Error(`unknown type: ${JSON.stringify(type)}`);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            if (domain[name] == null) {
                continue;
            }
            const type = domainFieldTypes[name];
            if (!type) {
                throw new Error(`invalid typed-data domain key: ${JSON.stringify(name)}`);
            }
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct('EIP712Domain', { EIP712Domain: domainFields }, domain);
    }
    static encode(domain, types, value) {
        return (0, utils_1.concat)([
            '0x1901',
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value),
        ]);
    }
    static hash(domain, types, value) {
        return (0, web3_utils_1.keccak256)(TypedDataEncoder.encode(domain, types, value));
    }
    static async resolveNames(domain, types, value, resolveName) {
        domain = Object.assign({}, domain);
        for (const key in domain) {
            if (domain[key] == null) {
                delete domain[key];
            }
        }
        const ensCache = {};
        if (domain.verifyingContract && !(0, web3_validator_1.isHexString)(domain.verifyingContract, 20)) {
            ensCache[domain.verifyingContract] = '0x';
        }
        const encoder = TypedDataEncoder.from(types);
        encoder.visit(value, (type, value) => {
            if (type === 'address' && !(0, web3_validator_1.isHexString)(value, 20)) {
                ensCache[value] = '0x';
            }
            return value;
        });
        for (const name in ensCache) {
            ensCache[name] = await resolveName(name);
        }
        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
            domain.verifyingContract = ensCache[domain.verifyingContract];
        }
        value = encoder.visit(value, (type, value) => {
            if (type === 'address' && ensCache[value]) {
                return ensCache[value];
            }
            return value;
        });
        return { domain, value };
    }
    static getPayload(domain, types, value) {
        TypedDataEncoder.hashDomain(domain);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach(name => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        types = encoder.types;
        const typesWithDomain = Object.assign({}, types);
        if (typesWithDomain.EIP712Domain != null) {
            throw new Error('types must not contain EIP712Domain type');
        }
        typesWithDomain.EIP712Domain = domainTypes;
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                if (type.match(/^bytes(\d*)/)) {
                    return (0, web3_utils_1.toHex)(value);
                }
                if (type.match(/^u?int/)) {
                    return (0, web3_utils_1.toBigInt)(value).toString();
                }
                switch (type) {
                    case 'address':
                        return value.toLowerCase();
                    case 'bool':
                        return !!value;
                    case 'string':
                        if (typeof value !== 'string') {
                            throw new Error('invalid string');
                        }
                        return value;
                }
                throw new Error(`unsupported type: ${type}`);
            }),
        };
    }
}
exports.TypedDataEncoder = TypedDataEncoder;
_TypedDataEncoder_types = new WeakMap(), _TypedDataEncoder_fullTypes = new WeakMap(), _TypedDataEncoder_encoderCache = new WeakMap(), _TypedDataEncoder_instances = new WeakSet(), _TypedDataEncoder_getEncoder = function _TypedDataEncoder_getEncoder(type) {
    {
        const encoder = getBaseEncoder(type);
        if (encoder) {
            return encoder;
        }
    }
    const array = splitArray(type).array;
    if (array) {
        const subtype = array.prefix;
        const subEncoder = this.getEncoder(subtype);
        return (value) => {
            if (!(array.count === -1 || array.count === value.length)) {
                throw new Error(`array length mismatch; expected length ${array.count}`);
            }
            let result = value.map(subEncoder);
            if (__classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, "f").has(subtype)) {
                result = result.map(web3_utils_1.keccak256);
            }
            return (0, web3_utils_1.keccak256)((0, utils_1.concat)(result));
        };
    }
    const fields = this.types[type];
    if (fields) {
        const encodedType = (0, utils_1.id)(__classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, "f").get(type));
        return (value) => {
            const values = fields.map(({ name, type }) => {
                const result = this.getEncoder(type)(value[name]);
                if (__classPrivateFieldGet(this, _TypedDataEncoder_fullTypes, "f").has(type)) {
                    return (0, web3_utils_1.keccak256)(result);
                }
                return result;
            });
            values.unshift(encodedType);
            return (0, utils_1.concat)(values);
        };
    }
    throw new Error(`unknown type: ${JSON.stringify(type)}`);
};
//# sourceMappingURL=TypedDataEncoder.js.map
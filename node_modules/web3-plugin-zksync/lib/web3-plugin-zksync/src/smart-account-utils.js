"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateTransactionMultisigECDSA = exports.populateTransactionECDSA = exports.signPayloadWithMultipleECDSA = exports.signPayloadWithECDSA = void 0;
const utils_1 = require("./utils");
const web3_eth_accounts_1 = require("web3-eth-accounts");
const constants_1 = require("./constants");
const utils = __importStar(require("./utils"));
const signPayloadWithECDSA = (payload, secret) => {
    const account = typeof secret === 'string' ? (0, web3_eth_accounts_1.privateKeyToAccount)(secret) : secret;
    return (0, web3_eth_accounts_1.signMessageWithPrivateKey)(payload.toString(), account.privateKey).signature;
};
exports.signPayloadWithECDSA = signPayloadWithECDSA;
const signPayloadWithMultipleECDSA = (payload, secret) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error('Multiple keys are required for multisig signing!');
    }
    const signatures = secret.map(key => (0, utils_1.toBytes)((0, exports.signPayloadWithECDSA)(payload, key)));
    return (0, utils_1.concat)(signatures);
};
exports.signPayloadWithMultipleECDSA = signPayloadWithMultipleECDSA;
const populateTransactionECDSA = async (tx, secret, provider) => {
    if (!provider) {
        throw new Error('Provider is required but is not provided!');
    }
    const account = typeof secret === 'object' && secret.privateKey
        ? secret
        : (0, web3_eth_accounts_1.privateKeyToAccount)(secret);
    provider._eip712Signer = async () => {
        if (!provider.eip712) {
            provider.eip712 = new utils.EIP712Signer(account, Number(await provider.eth.getChainId()));
        }
        return provider.eip712;
    };
    tx.from = account.address;
    tx.type = constants_1.EIP712_TX_TYPE;
    return provider.populateTransaction(tx);
};
exports.populateTransactionECDSA = populateTransactionECDSA;
const populateTransactionMultisigECDSA = async (tx, secret, provider) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error('Multiple keys are required to build the transaction!');
    }
    return (0, exports.populateTransactionECDSA)(tx, secret[0], provider);
};
exports.populateTransactionMultisigECDSA = populateTransactionMultisigECDSA;
//# sourceMappingURL=smart-account-utils.js.map
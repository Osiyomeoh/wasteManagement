import { type BlockNumberOrTag } from 'web3-types';
import type { Bytes, DataFormat, Numbers, Transaction, TransactionReceipt } from 'web3-types';
import { Network as ZkSyncNetwork, TransactionStatus } from './types';
import type { Address, TransactionOverrides, PaymasterParams } from './types';
import { Web3ZkSync } from './web3zksync';
import * as utils from './utils';
export declare class Web3ZKsyncL2 extends Web3ZkSync {
    eip712: utils.EIP712Signer;
    getZKTransactionReceipt<ReturnFormat extends DataFormat>(transactionHash: Bytes, returnFormat?: ReturnFormat): Promise<{
        readonly transactionHash: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly transactionIndex: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly blockHash: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly blockNumber: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly from: string;
        readonly to: string;
        readonly cumulativeGasUsed: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly gasUsed: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly effectiveGasPrice?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly contractAddress?: string | undefined;
        readonly logs: {
            readonly id?: string | undefined;
            readonly removed?: boolean | undefined;
            readonly logIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly transactionIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly transactionHash?: import("web3").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockHash?: import("web3").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockNumber?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly address?: string | undefined;
            readonly data?: import("web3").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly topics?: import("web3").ByteTypes[ReturnFormat["bytes"]][] | undefined;
            l1BatchNumber: import("web3").NumberTypes[ReturnFormat["number"]];
        }[];
        readonly logsBloom: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly root: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly status: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly type?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
        events?: {
            [x: string]: {
                readonly event: string;
                readonly id?: string | undefined;
                readonly logIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly transactionIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly transactionHash?: string | undefined;
                readonly blockHash?: string | undefined;
                readonly blockNumber?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly address: string;
                readonly topics: string[];
                readonly data: string;
                readonly raw?: {
                    data: string;
                    topics: unknown[];
                } | undefined;
                readonly returnValues: {
                    [x: string]: unknown;
                };
                readonly signature?: string | undefined;
            };
        } | undefined;
        l1BatchNumber: import("web3").NumberTypes[ReturnFormat["number"]];
        l1BatchTxIndex: import("web3").NumberTypes[ReturnFormat["number"]];
        l2ToL1Logs: {
            blockNumber: import("web3").NumberTypes[ReturnFormat["number"]];
            blockHash: string;
            l1BatchNumber: import("web3").NumberTypes[ReturnFormat["number"]];
            transactionIndex: import("web3").NumberTypes[ReturnFormat["number"]];
            shardId: import("web3").NumberTypes[ReturnFormat["number"]];
            isService: boolean;
            sender: string;
            key: string;
            value: string;
            transactionHash: string;
            logIndex: import("web3").NumberTypes[ReturnFormat["number"]];
        }[];
    } | undefined>;
    _getPriorityOpConfirmationL2ToL1Log(txHash: string, index?: number): Promise<{
        l2ToL1LogIndex: number;
        l2ToL1Log: {
            blockNumber: string | number | bigint;
            blockHash: string;
            l1BatchNumber: string | number | bigint;
            transactionIndex: string | number | bigint;
            shardId: string | number | bigint;
            isService: boolean;
            sender: string;
            key: string;
            value: string;
            transactionHash: string;
            logIndex: string | number | bigint;
        };
        l1BatchTxId: string | number | bigint;
    }>;
    getPriorityOpConfirmation(txHash: string, index?: number): Promise<{
        l1BatchNumber: string | number | bigint;
        l2MessageIndex: Numbers;
        l2TxNumberInBlock: string | number | bigint;
        proof: string[];
    }>;
    getL2TransactionFromPriorityOp(receipt: TransactionReceipt): Promise<string>;
    getTransactionStatus(txHash: string): Promise<TransactionStatus>;
    getWithdrawTx(transaction: {
        token: Address;
        amount: Numbers;
        from?: Address;
        to?: Address;
        bridgeAddress?: Address;
        paymasterParams?: PaymasterParams;
        overrides?: TransactionOverrides;
    }): Promise<import("web3").TransactionCall | {
        customData: {
            paymasterParams: PaymasterParams;
        };
        to: string;
        from?: string | undefined;
        value?: Numbers | undefined;
        accessList?: import("web3").AccessList | undefined;
        common?: import("web3").Common | undefined;
        gas?: Numbers | undefined;
        gasPrice?: Numbers | undefined;
        type?: Numbers | undefined;
        maxFeePerGas?: Numbers | undefined;
        maxPriorityFeePerGas?: Numbers | undefined;
        data?: Bytes | undefined;
        input?: Bytes | undefined;
        nonce?: Numbers | undefined;
        chain?: import("web3").ValidChains | undefined;
        hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
        chainId?: Numbers | undefined;
        networkId?: Numbers | undefined;
        gasLimit?: Numbers | undefined;
        yParity?: string | undefined;
        v?: Numbers | undefined;
        r?: Bytes | undefined;
        s?: Bytes | undefined;
    }>;
    getTransferTx(transaction: {
        to: Address;
        amount: Numbers;
        from?: Address;
        token?: Address;
        paymasterParams?: PaymasterParams;
        overrides?: TransactionOverrides;
    }): Promise<Transaction | {
        type: number;
        to: string;
        value: Numbers;
        customData: Transaction;
        s?: Bytes | undefined;
        nonce?: Numbers | undefined;
        from?: string | undefined;
        gas?: Numbers | undefined;
        gasLimit?: Numbers | undefined;
        gasPrice?: Numbers | undefined;
        maxPriorityFeePerGas?: Numbers | undefined;
        maxFeePerGas?: Numbers | undefined;
        chainId?: Numbers | undefined;
        accessList?: import("web3").AccessList | undefined;
        common?: import("web3").Common | undefined;
        chain?: import("web3").ValidChains | undefined;
        hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
        networkId?: Numbers | undefined;
        yParity?: string | undefined;
        v?: Numbers | undefined;
        r?: Bytes | undefined;
    } | {
        customData: {
            paymasterParams: PaymasterParams;
        };
        to: string;
        from?: string | undefined;
        value?: Numbers | undefined;
        accessList?: import("web3").AccessList | undefined;
        common?: import("web3").Common | undefined;
        gas?: Numbers | undefined;
        gasPrice?: Numbers | undefined;
        type?: Numbers | undefined;
        maxFeePerGas?: Numbers | undefined;
        maxPriorityFeePerGas?: Numbers | undefined;
        data?: Bytes | undefined;
        input?: Bytes | undefined;
        nonce?: Numbers | undefined;
        chain?: import("web3").ValidChains | undefined;
        hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
        chainId?: Numbers | undefined;
        networkId?: Numbers | undefined;
        gasLimit?: Numbers | undefined;
        yParity?: string | undefined;
        v?: Numbers | undefined;
        r?: Bytes | undefined;
        s?: Bytes | undefined;
    }>;
    static initWithDefaultProvider(zksyncNetwork?: ZkSyncNetwork): Web3ZKsyncL2;
    getBalance(address: Address, blockTag?: BlockNumberOrTag, tokenAddress?: Address): Promise<bigint>;
}
//# sourceMappingURL=web3zksync-l2.d.ts.map
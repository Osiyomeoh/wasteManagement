import type { FeeMarketEIP1559TxData } from 'web3-eth-accounts';
import type { Contract } from 'web3-eth-contract';
import type { Bytes, HexString, Numbers, Transaction, TransactionWithSenderAPI, TransactionReceipt, Log, TransactionReceiptBase } from 'web3-types';
import type { Web3ZKsyncL2 } from './web3zksync-l2';
import type { IERC20ABI } from './contracts/IERC20';
import type { IL2BridgeABI } from './contracts/IL2Bridge';
import type { IZkSyncABI } from './contracts/IZkSyncStateTransition';
import type { IBridgehubABI } from './contracts/IBridgehub';
import type { IContractDeployerABI } from './contracts/IContractDeployer';
import type { IL1MessengerABI } from './contracts/IL1Messenger';
import type { IERC1271ABI } from './contracts/IERC1271';
import type { IL1BridgeABI } from './contracts/IL1ERC20Bridge';
import type { INonceHolderABI } from './contracts/INonceHolder';
export type DeepWriteable<T> = {
    -readonly [P in keyof T]: DeepWriteable<T[P]>;
};
export type { Bytes, HexString, Numbers } from 'web3-types';
export interface TransactionOverrides extends Omit<Transaction, 'to' | 'data' | 'input'> {
}
export declare const ZeroAddress: Address;
export declare const ZeroHash: string;
export type Address = string;
export type Signature = string;
export declare enum Network {
    Mainnet = 1,
    Ropsten = 3,
    Rinkeby = 4,
    Goerli = 5,
    Sepolia = 6,
    Localhost = 9,
    EraTestNode = 10
}
export declare enum PriorityQueueType {
    Deque = 0,
    HeapBuffer = 1,
    Heap = 2
}
export declare enum PriorityOpTree {
    Full = 0,
    Rollup = 1
}
export declare enum TransactionStatus {
    NotFound = "not-found",
    Processing = "processing",
    Committed = "committed",
    Finalized = "finalized"
}
export type PaymasterParams = {
    paymaster: Address;
    paymasterInput: Bytes;
};
export type Eip712Meta = {
    gasPerPubdata?: Numbers;
    factoryDeps?: Bytes[];
    customSignature?: Bytes;
    paymasterParams?: PaymasterParams;
};
export type BlockTag = Numbers | string | 'committed' | 'finalized' | 'latest' | 'earliest' | 'pending';
export type DeploymentType = 'create' | 'createAccount' | 'create2' | 'create2Account';
export interface Token {
    l1Address: Address;
    l2Address: Address;
    name: string;
    symbol: string;
    decimals: number;
}
export interface Fee {
    gasLimit: bigint;
    gasPerPubdataLimit: bigint;
    maxPriorityFeePerGas: bigint;
    maxFeePerGas: bigint;
}
export interface MessageProof {
    id: number;
    proof: string[];
    root: string;
}
export interface zkSyncTxData extends FeeMarketEIP1559TxData {
    readonly l1BatchNumber: null | number;
    readonly l1BatchTxIndex: null | number;
}
export interface L2ToL1Log {
    blockNumber: number;
    blockHash: string;
    l1BatchNumber: number;
    transactionIndex: number;
    shardId: number;
    isService: boolean;
    sender: string;
    key: string;
    value: string;
    transactionHash: string;
    logIndex: number;
}
export declare type TransactionRequest = DeepWriteable<TransactionWithSenderAPI & {
    customData?: null | Eip712Meta;
    type?: TransactionWithSenderAPI['type'] & Numbers;
}>;
export interface PriorityL1OpResponse {
    waitL1Commit(confirmation?: number): Promise<TransactionReceipt>;
    wait(confirmation?: number): Promise<TransactionReceipt>;
    waitFinalize(confirmation?: number): Promise<TransactionReceipt>;
    hash: string;
}
export interface PriorityL2OpResponse {
    hash: string;
    wait(confirmation?: number): Promise<TransactionReceipt>;
    waitFinalize(confirmation?: number): Promise<TransactionReceipt>;
}
export type PriorityOpResponse = PriorityL1OpResponse | PriorityL2OpResponse;
export type BalancesMap = {
    [key: string]: bigint;
};
export interface DeploymentInfo {
    sender: Address;
    bytecodeHash: string;
    deployedAddress: Address;
}
export interface ApprovalBasedPaymasterInput {
    type: 'ApprovalBased';
    token: Address;
    minimalAllowance: Numbers;
    innerInput: Bytes;
}
export interface GeneralPaymasterInput {
    type: 'General';
    innerInput: Bytes;
}
export interface EthereumSignature {
    v: number;
    r: Bytes;
    s: Bytes;
}
export type PaymasterInput = ApprovalBasedPaymasterInput | GeneralPaymasterInput;
export declare enum AccountAbstractionVersion {
    None = 0,
    Version1 = 1
}
export declare enum AccountNonceOrdering {
    Sequential = 0,
    Arbitrary = 1
}
export interface ContractAccountInfo {
    supportedAAVersion: AccountAbstractionVersion;
    nonceOrdering: AccountNonceOrdering;
}
export interface BatchDetails {
    number: number;
    timestamp: number;
    l1TxCount: number;
    l2TxCount: number;
    rootHash?: string;
    status: string;
    commitTxHash?: string;
    committedAt?: Date;
    proveTxHash?: string;
    provenAt?: Date;
    executeTxHash?: string;
    executedAt?: Date;
    l1GasPrice: number;
    l2FairGasPrice: number;
}
export interface BlockDetails {
    number: bigint;
    timestamp: bigint;
    l1BatchNumber: bigint;
    l1TxCount: bigint;
    l2TxCount: bigint;
    rootHash?: string;
    status: string;
    commitTxHash?: string;
    committedAt?: Date;
    proveTxHash?: string;
    provenAt?: Date;
    executeTxHash?: string;
    executedAt?: Date;
}
export interface TransactionDetails {
    isL1Originated: boolean;
    status: string;
    fee: Numbers;
    initiatorAddress: Address;
    receivedAt: Date;
    ethCommitTxHash?: string;
    ethProveTxHash?: string;
    ethExecuteTxHash?: string;
}
export interface FullDepositFee {
    maxFeePerGas?: bigint;
    maxPriorityFeePerGas?: bigint;
    gasPrice?: bigint;
    baseCost: bigint;
    l1GasLimit: bigint;
    l2GasLimit: bigint;
}
export interface RawBlockTransaction {
    common_data: {
        L2: {
            nonce: number;
            fee: {
                gas_limit: bigint;
                max_fee_per_gas: bigint;
                max_priority_fee_per_gas: bigint;
                gas_per_pubdata_limit: bigint;
            };
            initiatorAddress: Address;
            signature: Uint8Array;
            transactionType: string;
            input: {
                hash: string;
                data: Uint8Array;
            };
            paymasterParams: {
                paymaster: Address;
                paymasterInput: Uint8Array;
            };
        };
    };
    execute: {
        calldata: string;
        contractAddress: Address;
        factoryDeps: Bytes[];
        value: bigint;
    };
    received_timestamp_ms: number;
    raw_bytes: string;
}
export interface FinalizeWithdrawalParams {
    l1BatchNumber: number | null | Numbers;
    l2MessageIndex: number;
    l2TxNumberInBlock: number | null;
    message: any;
    sender: string;
    proof: string[];
}
export interface StorageProof {
    address: Address;
    storageProof: {
        index: Numbers;
        key: HexString;
        value: HexString;
        proof: HexString[];
    }[];
}
export type PayloadSigner = (payload: Bytes, secret?: any, provider?: Web3ZKsyncL2) => string;
export interface WalletBalances {
    [key: Address]: Numbers;
}
export type TransactionBuilder = (transaction: Eip712TxData, secret?: any, provider?: Web3ZKsyncL2) => Promise<Eip712TxData>;
export interface SmartAccountSigner {
    address: string;
    secret: any;
    payloadSigner?: PayloadSigner;
    transactionBuilder?: TransactionBuilder;
}
export interface TokenInfo {
    name: string;
    symbol: string;
    decimals: bigint;
    totalSupply: bigint;
}
export interface BridgeAddresses {
    l1Erc20DefaultBridge: Address;
    l2Erc20DefaultBridge: Address;
    l1WethBridge: Address;
    l2WethBridge: Address;
    l1SharedDefaultBridge: Address;
    l2SharedDefaultBridge: Address;
}
export interface ContractsAddresses extends BridgeAddresses {
    mainContract: string;
    bridgehubContractAddress: string;
}
export interface L2ToL1Proof {
    proof: HexString[];
    id: Numbers;
    root: HexString;
}
export interface EstimateFee {
    gas_limit: Numbers;
    gas_per_pubdata_limit: Numbers;
    max_fee_per_gas: Numbers;
    max_priority_fee_per_gas: Numbers;
}
export interface TypedDataDomain {
    name?: null | string;
    version?: null | string;
    chainId?: null | Numbers;
    verifyingContract?: null | string;
    salt?: null | Bytes;
}
export interface TypedDataField {
    name: string;
    type: string;
}
export type Eip712TxData = Omit<FeeMarketEIP1559TxData, 'gasPrice'> & {
    eip712Meta?: null | Eip712Meta;
    customData?: null | Eip712Meta;
    from?: Address;
    hash?: string;
    signature?: string;
    gasPrice?: Numbers | Uint8Array | null;
};
export type Eip712SignedInput = FeeMarketEIP1559TxData & {
    customData?: null | Eip712Meta;
    data: Bytes;
    value: Numbers;
    nonce: Numbers;
    gasLimit: Numbers;
    maxFeePerGas: Numbers;
    maxPriorityFeePerGas: Numbers;
    from?: Address;
    txType: Numbers;
    gasPerPubdataByteLimit?: Numbers;
    paymaster: Address;
    factoryDeps: Bytes[];
    paymasterInput: Bytes;
    [key: string]: unknown;
};
export type ZKTransactionReceiptLog = Log & {
    l1BatchNumber: Numbers;
};
export type ZKTransactionReceipt = TransactionReceiptBase<Numbers, Bytes, Bytes, ZKTransactionReceiptLog> & {
    l1BatchNumber: Numbers;
    l1BatchTxIndex: Numbers;
    l2ToL1Logs: L2ToL1Log[];
};
export interface OverridesReadOnly extends Omit<TransactionRequest, 'to' | 'data'> {
}
export type Overrides = DeepWriteable<OverridesReadOnly>;
export interface NameResolver {
    resolveName(name: string): Promise<null | string>;
}
export type ZKSyncContractsCollection = {
    Generic: {
        IERC20Contract: Contract<typeof IERC20ABI>;
        IERC1271Contract: Contract<typeof IERC1271ABI>;
    };
    L1: {
        ZkSyncMainContract: Contract<typeof IZkSyncABI>;
        BridgehubContract: Contract<typeof IBridgehubABI>;
        L1BridgeContract: Contract<typeof IL1BridgeABI>;
    };
    L2: {
        ContractDeployerContract: Contract<typeof IContractDeployerABI>;
        L1MessengerContract: Contract<typeof IL1MessengerABI>;
        L2BridgeContract: Contract<typeof IL2BridgeABI>;
        NonceHolderContract: Contract<typeof INonceHolderABI>;
    };
};
//# sourceMappingURL=types.d.ts.map
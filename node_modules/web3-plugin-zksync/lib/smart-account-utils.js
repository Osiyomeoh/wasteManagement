"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateTransactionMultisigECDSA = exports.populateTransactionECDSA = exports.signPayloadWithMultipleECDSA = exports.signPayloadWithECDSA = void 0;
const utils_1 = require("./utils");
const web3_eth_accounts_1 = require("web3-eth-accounts");
const utils = __importStar(require("./utils"));
const constants_1 = require("./constants");
const web3_utils_1 = require("web3-utils");
const signPayloadWithECDSA = (payload, secret) => {
    const account = typeof secret === 'string' ? (0, web3_eth_accounts_1.privateKeyToAccount)(secret) : secret;
    return (0, web3_eth_accounts_1.signMessageWithPrivateKey)(payload.toString(), account.privateKey).signature;
};
exports.signPayloadWithECDSA = signPayloadWithECDSA;
const signPayloadWithMultipleECDSA = (payload, secret) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error('Multiple keys are required for multisig signing!');
    }
    const signatures = secret.map(key => (0, utils_1.toBytes)((0, exports.signPayloadWithECDSA)(payload, key)));
    return (0, utils_1.concat)(signatures);
};
exports.signPayloadWithMultipleECDSA = signPayloadWithMultipleECDSA;
const populateTransactionECDSA = async (tx, secret, provider) => {
    var _a, _b, _c, _d;
    if (!provider) {
        throw new Error('Provider is required but is not provided!');
    }
    const account = typeof secret === 'object' && secret.privateKey
        ? secret
        : (0, web3_eth_accounts_1.privateKeyToAccount)(secret);
    provider._eip712Signer = async () => {
        if (!provider.eip712) {
            provider.eip712 = new utils.EIP712Signer(account, Number(await provider.eth.getChainId()));
        }
        return provider.eip712;
    };
    tx.type = constants_1.EIP712_TX_TYPE;
    tx.chainId = (0, web3_utils_1.format)({ format: 'uint' }, tx.chainId ?? (await provider.eth.getChainId()));
    tx.value = (0, web3_utils_1.format)({ format: 'uint' }, tx.value ? tx.value : 0n);
    tx.data ?? (tx.data = '0x');
    tx.gasPrice = (0, web3_utils_1.format)({ format: 'uint' }, tx.gasPrice ?? (await provider.eth.getGasPrice()));
    tx.nonce = (0, web3_utils_1.format)({ format: 'uint' }, tx.nonce ?? (await provider.eth.getTransactionCount(tx.from, 'pending')));
    tx.customData = tx.customData ?? {};
    (_a = tx.customData).gasPerPubdata ?? (_a.gasPerPubdata = constants_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);
    (_b = tx.customData).factoryDeps ?? (_b.factoryDeps = []);
    tx.from = tx.from ?? account.address;
    tx.type = (0, web3_utils_1.format)({ format: 'uint' }, constants_1.EIP712_TX_TYPE);
    tx.customData = tx.customData ?? {};
    (_c = tx.customData).gasPerPubdata ?? (_c.gasPerPubdata = constants_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);
    (_d = tx.customData).factoryDeps ?? (_d.factoryDeps = []);
    if (tx.from) {
        const code = await provider.eth.getCode(tx.from);
        const isContractAccount = code !== '0x';
        if (isContractAccount) {
            const web3Account = (typeof secret === 'string' ? (0, web3_eth_accounts_1.privateKeyToAccount)(secret) : secret);
            tx.gasLimit ?? (tx.gasLimit = await provider.estimateGas({
                ...tx,
                from: web3Account.address,
            }));
        }
    }
    tx.gasLimit ?? (tx.gasLimit = await provider.estimateGas(tx));
    return tx;
};
exports.populateTransactionECDSA = populateTransactionECDSA;
const populateTransactionMultisigECDSA = async (tx, secret, provider) => {
    if (!Array.isArray(secret) || secret.length < 2) {
        throw new Error('Multiple keys are required to build the transaction!');
    }
    return (0, exports.populateTransactionECDSA)(tx, secret[0], provider);
};
exports.populateTransactionMultisigECDSA = populateTransactionMultisigECDSA;
//# sourceMappingURL=smart-account-utils.js.map
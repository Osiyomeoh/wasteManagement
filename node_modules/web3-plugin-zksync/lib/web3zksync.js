"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3ZkSync = void 0;
const web3Utils = __importStar(require("web3-utils"));
const web3Accounts = __importStar(require("web3-eth-accounts"));
const web3_1 = require("web3");
const web3_eth_1 = require("web3-eth");
const Web3 = __importStar(require("web3"));
const web3_types_1 = require("web3-types");
const web3_utils_1 = require("web3-utils");
const web3_rpc_methods_1 = require("web3-rpc-methods");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const rpc_methods_1 = require("./rpc.methods");
const IL2Bridge_1 = require("./contracts/IL2Bridge");
const IERC20_1 = require("./contracts/IERC20");
const schemas_1 = require("./schemas");
const web3_eth_accounts_1 = require("web3-eth-accounts");
class Web3ZkSync extends Web3.Web3 {
    contractAddresses() {
        return this._contractAddresses;
    }
    constructor(providerOrContext) {
        super(providerOrContext);
        this._rpc = new rpc_methods_1.RpcMethods(this.requestManager);
        this._contractAddresses = {};
    }
    async l1ChainId(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.l1ChainId(returnFormat);
    }
    async _eip712Signer() {
        throw new Error('Must be implemented by the derived class!');
    }
    async getL1BatchNumber(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getL1BatchNumber(returnFormat);
    }
    async getL1BatchDetails(number, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getL1BatchDetails(number, returnFormat);
    }
    async getBlockDetails(number, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getBlockDetails(number, returnFormat);
    }
    async getTransactionDetails(txHash, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getTransactionDetails(txHash, returnFormat);
    }
    async getBytecodeByHash(bytecodeHash, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getBytecodeByHash(bytecodeHash, returnFormat);
    }
    async getRawBlockTransactions(number, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getRawBlockTransactions(number, returnFormat);
    }
    async estimateFee(transaction, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.estimateFee(transaction, returnFormat);
    }
    async getBaseTokenContractAddress() {
        if (!this.contractAddresses().baseToken) {
            this.contractAddresses().baseToken = await this._rpc.getBaseTokenL1Address();
        }
        return this.contractAddresses().baseToken;
    }
    async isEthBasedChain() {
        return (0, utils_1.isAddressEq)(await this.getBaseTokenContractAddress(), constants_1.ETH_ADDRESS_IN_CONTRACTS);
    }
    async isBaseToken(token) {
        return (0, utils_1.isETH)(token) || (0, utils_1.isAddressEq)(token, await this.getBaseTokenContractAddress());
    }
    async getTestnetPaymasterAddress() {
        return this._rpc.getTestnetPaymasterAddress();
    }
    async getDefaultBridgeAddresses() {
        if (!this.contractAddresses().erc20BridgeL1) {
            const addresses = await this._rpc.getBridgeContracts();
            this.contractAddresses().erc20BridgeL1 = addresses.l1Erc20DefaultBridge;
            this.contractAddresses().erc20BridgeL2 = addresses.l2Erc20DefaultBridge;
            this.contractAddresses().wethBridgeL1 = addresses.l1WethBridge;
            this.contractAddresses().wethBridgeL2 = addresses.l2WethBridge;
            this.contractAddresses().sharedBridgeL1 = addresses.l1SharedDefaultBridge;
            this.contractAddresses().sharedBridgeL2 = addresses.l2SharedDefaultBridge;
        }
        return {
            erc20L1: this.contractAddresses().erc20BridgeL1,
            erc20L2: this.contractAddresses().erc20BridgeL2,
            wethL1: this.contractAddresses().wethBridgeL1,
            wethL2: this.contractAddresses().wethBridgeL2,
            sharedL1: this.contractAddresses().sharedBridgeL1,
            sharedL2: this.contractAddresses().sharedBridgeL2,
        };
    }
    async estimateGasL1ToL2(transaction, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.estimateGasL1ToL2(transaction, returnFormat);
    }
    async getAllAccountBalances(address, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getAllAccountBalances(address, returnFormat);
    }
    async getMainContract(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getMainContract(returnFormat);
    }
    async getL1BatchBlockRange(number, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getL1BatchBlockRange(number, returnFormat);
    }
    async getProof(address, keys, l1BatchNumber, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getProof(address, keys, l1BatchNumber, returnFormat);
    }
    async getL2ToL1LogProof(txHash, l2ToL1LogIndex, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getL2ToL1LogProof(txHash, l2ToL1LogIndex, returnFormat);
    }
    async getBridgeContracts(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        return this._rpc.getBridgeContracts(returnFormat);
    }
    async getBridgehubContractAddress(returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        if (!this.contractAddresses().bridgehubContract) {
            this.contractAddresses().bridgehubContract =
                await this._rpc.getBridgehubContractAddress(returnFormat);
        }
        return this.contractAddresses().bridgehubContract;
    }
    async estimateL1ToL2Execute(transaction, returnFormat = web3_1.DEFAULT_RETURN_FORMAT) {
        transaction.gasPerPubdataByte ?? (transaction.gasPerPubdataByte = constants_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
        transaction.caller ?? (transaction.caller = web3Accounts.create().address);
        const customData = {
            gasPerPubdata: transaction.gasPerPubdataByte,
        };
        if (transaction.factoryDeps) {
            Object.assign(customData, { factoryDeps: transaction.factoryDeps });
        }
        return this.estimateGasL1ToL2({
            from: transaction.caller,
            data: transaction.calldata,
            to: transaction.contractAddress,
            value: transaction.l2Value ? web3Utils.toHex(transaction.l2Value) : undefined,
            customData,
        }, returnFormat);
    }
    async l2TokenAddress(token) {
        if ((0, utils_1.isAddressEq)(token, constants_1.LEGACY_ETH_ADDRESS)) {
            token = constants_1.ETH_ADDRESS_IN_CONTRACTS;
        }
        const baseToken = await this.getBaseTokenContractAddress();
        if ((0, utils_1.isAddressEq)(token, baseToken)) {
            return constants_1.L2_BASE_TOKEN_ADDRESS;
        }
        const bridgeAddresses = await this.getDefaultBridgeAddresses();
        const contract = new Web3.Contract(IL2Bridge_1.IL2BridgeABI, bridgeAddresses.sharedL2);
        contract.setProvider(this.provider);
        return await contract.methods.l2TokenAddress(token).call();
    }
    async getMainContractAddress() {
        if (!this.contractAddresses().mainContract) {
            this.contractAddresses().mainContract = await this._rpc.getMainContract();
        }
        return this.contractAddresses().mainContract;
    }
    async getTokenBalance(token, walletAddress) {
        const erc20 = new this.eth.Contract(IERC20_1.IERC20ABI, token);
        return await erc20.methods.balanceOf(walletAddress).call();
    }
    fillCustomData(data) {
        const customData = { ...data };
        customData.gasPerPubdata ?? (customData.gasPerPubdata = constants_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);
        customData.factoryDeps ?? (customData.factoryDeps = []);
        return customData;
    }
    prepareTransaction(transaction) {
        if (!transaction.customData) {
            return transaction;
        }
        const { customData, ...tx } = transaction;
        tx.eip712Meta = {
            gasPerPubdata: web3Utils.toHex(customData?.gasPerPubdata ?? 0),
        };
        if (customData?.factoryDeps) {
            const factoryDeps = customData.factoryDeps.map(dep => Array.from((0, web3_eth_accounts_1.toUint8Array)(dep)));
            tx.eip712Meta.factoryDeps = factoryDeps;
        }
        if (customData?.paymasterParams) {
            tx.eip712Meta.paymasterParams = {
                paymaster: (0, web3_utils_1.toHex)(customData.paymasterParams.paymaster),
                paymasterInput: Array.from((0, web3_eth_accounts_1.toUint8Array)(customData.paymasterParams.paymasterInput)),
            };
        }
        return tx;
    }
    async estimateGas(transaction) {
        const tx = (0, web3_utils_1.format)(web3_eth_1.transactionSchema, { ...transaction, to: transaction.to ?? constants_1.ZERO_ADDRESS }, web3_types_1.ETH_DATA_FORMAT);
        const dataToSend = this.prepareTransaction({
            ...tx,
            customData: transaction.customData,
        });
        const gas = await this.requestManager.send({
            method: 'eth_estimateGas',
            params: [dataToSend],
        });
        return web3Utils.toBigInt(gas);
    }
    async populateTransactionAndGasPrice(transaction) {
        transaction.nonce =
            transaction.nonce ?? (await this.eth.getTransactionCount(transaction.from, 'pending'));
        const txForBuilder = { ...transaction };
        if (txForBuilder.type && (0, web3_utils_1.toHex)(txForBuilder.type) === (0, web3_utils_1.toHex)(constants_1.EIP712_TX_TYPE)) {
            delete txForBuilder.type;
        }
        const populated = await (0, web3_eth_1.transactionBuilder)({
            transaction: txForBuilder,
            web3Context: this,
        });
        if (transaction.customData) {
            populated.customData = transaction.customData;
            populated.type = constants_1.EIP712_TX_TYPE;
        }
        else {
            populated.type = transaction.type === undefined ? 2n : transaction.type;
        }
        const formatted = web3Utils.format(schemas_1.EIP712TransactionSchema, populated);
        delete formatted.input;
        delete formatted.chain;
        delete formatted.hardfork;
        delete formatted.networkId;
        if (formatted.accessList &&
            Array.isArray(formatted.accessList) &&
            formatted.accessList.length === 0) {
            delete formatted.accessList;
        }
        formatted.gasLimit = formatted.gasLimit ?? (await this.estimateGas(formatted));
        if (formatted.type === 0n) {
            formatted.gasPrice =
                formatted.gasPrice ?? (await (0, web3_eth_1.getGasPrice)(this, web3_1.DEFAULT_RETURN_FORMAT));
            return formatted;
        }
        if (formatted.type === 2n && formatted.gasPrice) {
            formatted.maxFeePerGas = formatted.maxFeePerGas ?? formatted.gasPrice;
            formatted.maxPriorityFeePerGas = formatted.maxPriorityFeePerGas ?? formatted.gasPrice;
            delete formatted.gasPrice;
            return formatted;
        }
        if (formatted.maxPriorityFeePerGas && formatted.maxFeePerGas) {
            return formatted;
        }
        const gasFees = await this.eth.calculateFeeData();
        if (gasFees.maxFeePerGas && gasFees.maxPriorityFeePerGas) {
            if (formatted.type !== BigInt(constants_1.EIP712_TX_TYPE)) {
                formatted.maxFeePerGas =
                    formatted.maxFeePerGas ?? web3Utils.toBigInt(gasFees.maxFeePerGas);
                formatted.maxPriorityFeePerGas =
                    formatted.maxPriorityFeePerGas ??
                        (web3Utils.toBigInt(formatted.maxFeePerGas) >
                            web3Utils.toBigInt(gasFees.maxPriorityFeePerGas)
                            ? formatted.maxFeePerGas
                            : gasFees.maxPriorityFeePerGas);
            }
        }
        else {
            formatted.maxFeePerGas = formatted.maxFeePerGas ?? formatted.gasPrice;
            formatted.maxPriorityFeePerGas = formatted.maxPriorityFeePerGas ?? formatted.gasPrice;
        }
        if (gasFees.gasPrice && (!formatted.maxFeePerGas || !formatted.maxPriorityFeePerGas)) {
            formatted.gasPrice = gasFees.gasPrice;
        }
        return formatted;
    }
    async populateTransaction(transaction) {
        if ((!transaction.type ||
            (transaction.type && (0, web3_utils_1.toHex)(transaction.type) !== (0, web3_utils_1.toHex)(constants_1.EIP712_TX_TYPE))) &&
            !transaction.customData) {
            return this.populateTransactionAndGasPrice(transaction);
        }
        const populated = (await this.populateTransactionAndGasPrice(transaction));
        populated.value ?? (populated.value = 0n);
        populated.data ?? (populated.data = '0x');
        populated.customData = this.fillCustomData(transaction.customData);
        return populated;
    }
    async signTransaction(tx) {
        if (tx.type && (0, web3_utils_1.toHex)(tx.type) === (0, web3_utils_1.toHex)(constants_1.EIP712_TX_TYPE)) {
            const signer = await this._eip712Signer();
            tx.chainId = signer.getDomain().chainId;
            tx.customData = {
                ...(tx.customData || {}),
                customSignature: await signer.sign(tx),
            };
            return utils_1.EIP712.serialize(tx);
        }
        const account = this.eth.accounts.wallet.get(tx.from);
        if (!account) {
            throw new Error('Account not found');
        }
        const res = await this.eth.accounts.signTransaction(tx, account?.privateKey);
        return res.rawTransaction;
    }
    async sendRawTransaction(signedTx) {
        return web3_rpc_methods_1.ethRpcMethods.sendRawTransaction(this.requestManager, signedTx);
    }
}
exports.Web3ZkSync = Web3ZkSync;
//# sourceMappingURL=web3zksync.js.map
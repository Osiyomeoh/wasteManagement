"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZKsyncPlugin = void 0;
const web3_eth_contract_1 = require("web3-eth-contract");
const web3_core_1 = require("web3-core");
const IERC20_1 = require("./contracts/IERC20");
const rpc_methods_1 = require("./rpc.methods");
const constants = __importStar(require("./constants"));
const IL2Bridge_1 = require("./contracts/IL2Bridge");
const IZkSyncStateTransition_1 = require("./contracts/IZkSyncStateTransition");
const IBridgehub_1 = require("./contracts/IBridgehub");
const IContractDeployer_1 = require("./contracts/IContractDeployer");
const IL1Messenger_1 = require("./contracts/IL1Messenger");
const IERC1271_1 = require("./contracts/IERC1271");
const IL1ERC20Bridge_1 = require("./contracts/IL1ERC20Bridge");
const INonceHolder_1 = require("./contracts/INonceHolder");
const zksync_wallet_1 = require("./zksync-wallet");
const web3zksync_l2_1 = require("./web3zksync-l2");
const web3zksync_l1_1 = require("./web3zksync-l1");
const smart_account_1 = require("./smart-account");
class ZKsyncPlugin extends web3_core_1.Web3PluginBase {
    get Contracts() {
        if (this.contracts) {
            return Promise.resolve(this.contracts);
        }
        return this.initContracts();
    }
    get ContractsAddresses() {
        if (this.contractsAddresses) {
            return Promise.resolve(this.contractsAddresses);
        }
        return this.initContractsAddresses();
    }
    constructor(providerOrContextL2) {
        super(providerOrContextL2);
        this.pluginNamespace = 'ZKsync';
        if (providerOrContextL2 instanceof web3zksync_l2_1.Web3ZKsyncL2) {
            this.L2 = providerOrContextL2;
        }
        else {
            this.L2 = new web3zksync_l2_1.Web3ZKsyncL2(providerOrContextL2);
        }
        this._l2BridgeContracts = {};
        this._erc20Contracts = {};
        const self = this;
        class ZKsyncWalletWithFullContext extends zksync_wallet_1.ZKsyncWallet {
            constructor(privateKey) {
                super(privateKey, self.L2, self.L1);
            }
        }
        class ZKsyncAccountWithFullContext extends smart_account_1.SmartAccount {
            constructor(signer) {
                super(signer, self.L2);
            }
        }
        class ZKsyncECDSASmartAccountWithFullContext {
            static create(address, secret) {
                return smart_account_1.ECDSASmartAccount.create(address, secret, self.L2);
            }
        }
        class ZKsyncMultisigECDSASmartAccountWithFullContext extends smart_account_1.MultisigECDSASmartAccount {
            static create(address, secret) {
                return smart_account_1.MultisigECDSASmartAccount.create(address, secret, self.L2);
            }
        }
        this.Wallet = ZKsyncWalletWithFullContext;
        this.SmartAccount = ZKsyncAccountWithFullContext;
        this.ECDSASmartAccount = ZKsyncECDSASmartAccountWithFullContext;
        this.MultisigECDSASmartAccount = ZKsyncMultisigECDSASmartAccountWithFullContext;
        this.initWallet();
    }
    async initContracts() {
        if (!this.L1 || !this.L2) {
            throw new Error('Contracts cannot be initialized because a Web3 instance is not yet linked to ZkSync plugin');
        }
        const { mainContract, bridgehubContractAddress, l1SharedDefaultBridge, l2SharedDefaultBridge, } = await this.ContractsAddresses;
        const contractsCollection = {
            Generic: {
                IERC20Contract: new web3_eth_contract_1.Contract(IERC20_1.IERC20ABI),
                IERC1271Contract: new web3_eth_contract_1.Contract(IERC1271_1.IERC1271ABI),
            },
            L1: {
                ZkSyncMainContract: new web3_eth_contract_1.Contract(IZkSyncStateTransition_1.IZkSyncABI, mainContract, this.L1),
                BridgehubContract: new web3_eth_contract_1.Contract(IBridgehub_1.IBridgehubABI, bridgehubContractAddress, this.L1),
                L1BridgeContract: new web3_eth_contract_1.Contract(IL1ERC20Bridge_1.IL1BridgeABI, l1SharedDefaultBridge, this.L1),
            },
            L2: {
                ContractDeployerContract: new web3_eth_contract_1.Contract(IContractDeployer_1.IContractDeployerABI, constants.CONTRACT_DEPLOYER_ADDRESS, this.L2),
                L1MessengerContract: new web3_eth_contract_1.Contract(IL1Messenger_1.IL1MessengerABI, constants.L1_MESSENGER_ADDRESS, this.L2),
                NonceHolderContract: new web3_eth_contract_1.Contract(INonceHolder_1.INonceHolderABI, constants.NONCE_HOLDER_ADDRESS, this.L2),
                L2BridgeContract: new web3_eth_contract_1.Contract(IL2Bridge_1.IL2BridgeABI, l2SharedDefaultBridge, this.L2),
            },
        };
        this.contracts = contractsCollection;
        return contractsCollection;
    }
    async initContractsAddresses() {
        const [mainContract, bridgehubContractAddress, bridgeContracts] = await Promise.all([
            this.rpc.getMainContract(),
            this.rpc.getBridgehubContractAddress(),
            this.rpc.getBridgeContracts(),
        ]);
        this.contractsAddresses = Promise.resolve({
            mainContract,
            bridgehubContractAddress,
            ...bridgeContracts,
        });
        return this.contractsAddresses;
    }
    link(parentContext) {
        super.link(parentContext);
        this.L1 = new web3zksync_l1_1.Web3ZKsyncL1(parentContext);
        this.initWallet();
    }
    initWallet() {
        const self = this;
        class ZKSyncWalletWithFullContext extends zksync_wallet_1.ZKsyncWallet {
            constructor(privateKey) {
                super(privateKey, self.L2, self.L1);
            }
        }
        this.Wallet = ZKSyncWalletWithFullContext;
    }
    get rpc() {
        if (!this._rpc) {
            this._rpc = new rpc_methods_1.RpcMethods(this.L2.requestManager);
        }
        return this._rpc;
    }
    updateProviders(contextL1, contextL2) {
        this.L1 = contextL1 instanceof web3zksync_l1_1.Web3ZKsyncL1 ? contextL1 : new web3zksync_l1_1.Web3ZKsyncL1(contextL1);
        this.L2 = contextL2 instanceof web3zksync_l2_1.Web3ZKsyncL2 ? contextL2 : new web3zksync_l2_1.Web3ZKsyncL2(contextL2);
    }
    getL2BridgeContract(address) {
        if (!this._l2BridgeContracts[address]) {
            this._l2BridgeContracts[address] = new web3_eth_contract_1.Contract(IL2Bridge_1.IL2BridgeABI, address);
            this._l2BridgeContracts[address].link(this.L2);
        }
        return this._l2BridgeContracts[address];
    }
    erc20(address) {
        if (!this._erc20Contracts[address]) {
            this._erc20Contracts[address] = new web3_eth_contract_1.Contract(IERC20_1.IERC20ABI, address);
            this._erc20Contracts[address].link(this.L2);
        }
        return this._erc20Contracts[address];
    }
    async getL1Address(token) {
        if (token == constants.ETH_ADDRESS) {
            return constants.ETH_ADDRESS;
        }
        else {
            const bridgeAddresses = await this.L2.getDefaultBridgeAddresses();
            if (bridgeAddresses.wethL2 !== constants.ZERO_ADDRESS) {
                const l2Bridge = this.getL2BridgeContract(bridgeAddresses.wethL2);
                try {
                    const l1Token = await l2Bridge.methods.l1TokenAddress(token).call();
                    if (l1Token !== constants.ZERO_ADDRESS) {
                        return l1Token;
                    }
                }
                catch (e) {
                    throw new Error(`Error getting L1 address for token ${token}. ${JSON.stringify(e)}`);
                }
            }
            const erc20Bridge = this.getL2BridgeContract(bridgeAddresses.erc20L2);
            return erc20Bridge.methods.l1TokenAddress(token).call();
        }
    }
    async getL2Address(token) {
        if (token == constants.ETH_ADDRESS) {
            return constants.ETH_ADDRESS;
        }
        else {
            const bridgeAddresses = await this.L2.getDefaultBridgeAddresses();
            if (bridgeAddresses.wethL2 !== constants.ZERO_ADDRESS) {
                const l2Bridge = this.getL2BridgeContract(bridgeAddresses.wethL2);
                try {
                    const l2WethToken = await l2Bridge.methods.l2TokenAddress(token).call();
                    if (l2WethToken !== constants.ZERO_ADDRESS) {
                        return l2WethToken;
                    }
                }
                catch (e) {
                    throw new Error(`Error getting L2 address for token ${token}. ${JSON.stringify(e)}`);
                }
            }
            const erc20Bridge = this.getL2BridgeContract(bridgeAddresses.erc20L2);
            return erc20Bridge.methods.l2TokenAddress(token).call();
        }
    }
}
exports.ZKsyncPlugin = ZKsyncPlugin;
//# sourceMappingURL=plugin.js.map
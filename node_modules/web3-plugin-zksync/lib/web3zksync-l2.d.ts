import { type BlockNumberOrTag } from 'web3-types';
import type { Bytes, DataFormat, Numbers, Transaction, TransactionReceipt } from 'web3-types';
import { Network as ZkSyncNetwork, TransactionStatus } from './types';
import type { Address, TransactionOverrides, PaymasterParams } from './types';
import { Web3ZkSync } from './web3zksync';
import * as utils from './utils';
export declare class Web3ZKsyncL2 extends Web3ZkSync {
    eip712: utils.EIP712Signer;
    getZKTransactionReceipt<ReturnFormat extends DataFormat>(transactionHash: Bytes, returnFormat?: ReturnFormat): Promise<{
        readonly transactionHash: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly transactionIndex: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly blockHash: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly blockNumber: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly from: import("web3").Address;
        readonly to: import("web3").Address;
        readonly cumulativeGasUsed: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly gasUsed: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly effectiveGasPrice?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly contractAddress?: import("web3").Address | undefined;
        readonly logs: {
            readonly id?: string | undefined;
            readonly removed?: boolean | undefined;
            readonly logIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly transactionIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly transactionHash?: import("web3").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockHash?: import("web3").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockNumber?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly address?: import("web3").Address | undefined;
            readonly data?: import("web3").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly topics?: import("web3").ByteTypes[ReturnFormat["bytes"]][] | undefined;
            l1BatchNumber: import("web3").NumberTypes[ReturnFormat["number"]];
        }[];
        readonly logsBloom: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly root: import("web3").ByteTypes[ReturnFormat["bytes"]];
        readonly status: import("web3").NumberTypes[ReturnFormat["number"]];
        readonly type?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
        events?: {
            [x: string]: {
                readonly event: string;
                readonly id?: string | undefined;
                readonly logIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly transactionIndex?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly transactionHash?: import("web3").HexString32Bytes | undefined;
                readonly blockHash?: import("web3").HexString32Bytes | undefined;
                readonly blockNumber?: import("web3").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly address: string;
                readonly topics: import("web3").HexString[];
                readonly data: import("web3").HexString;
                readonly raw?: {
                    data: string;
                    topics: unknown[];
                } | undefined;
                readonly returnValues: {
                    [x: string]: unknown;
                };
                readonly signature?: import("web3").HexString | undefined;
            };
        } | undefined;
        l1BatchNumber: import("web3").NumberTypes[ReturnFormat["number"]];
        l1BatchTxIndex: import("web3").NumberTypes[ReturnFormat["number"]];
        l2ToL1Logs: {
            blockNumber: import("web3").NumberTypes[ReturnFormat["number"]];
            blockHash: string;
            l1BatchNumber: import("web3").NumberTypes[ReturnFormat["number"]];
            transactionIndex: import("web3").NumberTypes[ReturnFormat["number"]];
            shardId: import("web3").NumberTypes[ReturnFormat["number"]];
            isService: boolean;
            sender: string;
            key: string;
            value: string;
            transactionHash: string;
            logIndex: import("web3").NumberTypes[ReturnFormat["number"]];
        }[];
    } | undefined>;
    _getPriorityOpConfirmationL2ToL1Log(txHash: string, index?: number): Promise<{
        l2ToL1LogIndex: number;
        l2ToL1Log: {
            blockNumber: string | number | bigint;
            blockHash: string;
            l1BatchNumber: string | number | bigint;
            transactionIndex: string | number | bigint;
            shardId: string | number | bigint;
            isService: boolean;
            sender: string;
            key: string;
            value: string;
            transactionHash: string;
            logIndex: string | number | bigint;
        };
        l1BatchTxId: string | number | bigint;
    }>;
    getPriorityOpConfirmation(txHash: string, index?: number): Promise<{
        l1BatchNumber: string | number | bigint;
        l2MessageIndex: Numbers;
        l2TxNumberInBlock: string | number | bigint;
        proof: string[];
    }>;
    getL2TransactionFromPriorityOp(receipt: TransactionReceipt): Promise<string>;
    getTransactionStatus(txHash: string): Promise<TransactionStatus>;
    getWithdrawTx(transaction: {
        token: Address;
        amount: Numbers;
        from?: Address;
        to?: Address;
        bridgeAddress?: Address;
        paymasterParams?: PaymasterParams;
        overrides?: TransactionOverrides;
    }): Promise<import("web3").TransactionCall | {
        customData: {
            paymasterParams: PaymasterParams;
        };
        to: import("web3").Address;
        from?: import("web3").Address;
        value?: Numbers;
        accessList?: import("web3").AccessList;
        common?: import("web3").Common;
        gas?: Numbers;
        gasPrice?: Numbers;
        type?: Numbers;
        maxFeePerGas?: Numbers;
        maxPriorityFeePerGas?: Numbers;
        data?: Bytes;
        input?: Bytes;
        nonce?: Numbers;
        chain?: import("web3").ValidChains;
        hardfork?: import("web3").Hardfork;
        chainId?: Numbers;
        networkId?: Numbers;
        gasLimit?: Numbers;
        yParity?: import("web3").Uint;
        v?: Numbers;
        r?: Bytes;
        s?: Bytes;
    }>;
    getTransferTx(transaction: {
        to: Address;
        amount: Numbers;
        from?: Address;
        token?: Address;
        paymasterParams?: PaymasterParams;
        overrides?: TransactionOverrides;
    }): Promise<Transaction | {
        type: number;
        to: string;
        value: string;
        customData: Transaction;
        r?: Bytes | undefined;
        s?: Bytes | undefined;
        nonce?: Numbers | undefined;
        from?: import("web3").Address | undefined;
        gas?: Numbers | undefined;
        gasLimit?: Numbers | undefined;
        gasPrice?: Numbers | undefined;
        maxPriorityFeePerGas?: Numbers | undefined;
        maxFeePerGas?: Numbers | undefined;
        chainId?: Numbers | undefined;
        accessList?: import("web3").AccessList | undefined;
        common?: import("web3").Common | undefined;
        chain?: import("web3").ValidChains | undefined;
        hardfork?: import("web3").Hardfork | undefined;
        networkId?: Numbers | undefined;
        yParity?: import("web3").Uint | undefined;
        v?: Numbers | undefined;
    } | {
        customData: {
            paymasterParams: PaymasterParams;
        };
        to: import("web3").Address;
        from?: import("web3").Address;
        value?: Numbers;
        accessList?: import("web3").AccessList;
        common?: import("web3").Common;
        gas?: Numbers;
        gasPrice?: Numbers;
        type?: Numbers;
        maxFeePerGas?: Numbers;
        maxPriorityFeePerGas?: Numbers;
        data?: Bytes;
        input?: Bytes;
        nonce?: Numbers;
        chain?: import("web3").ValidChains;
        hardfork?: import("web3").Hardfork;
        chainId?: Numbers;
        networkId?: Numbers;
        gasLimit?: Numbers;
        yParity?: import("web3").Uint;
        v?: Numbers;
        r?: Bytes;
        s?: Bytes;
    }>;
    static initWithDefaultProvider(zksyncNetwork?: ZkSyncNetwork): Web3ZKsyncL2;
    getBalance(address: Address, blockTag?: BlockNumberOrTag, tokenAddress?: Address): Promise<bigint>;
}
//# sourceMappingURL=web3zksync-l2.d.ts.map
import type * as web3Types from 'web3-types';
import * as Web3 from 'web3';
import type { PayableMethodObject } from 'web3-eth-contract';
import { Numbers, Transaction, TransactionHash, TransactionReceipt } from 'web3-types';
import type { Web3ZKsyncL2 } from './web3zksync-l2';
import type { EIP712Signer } from './utils';
import { Address, FinalizeWithdrawalParams, FullDepositFee, TransactionOverrides, PaymasterParams, PriorityOpResponse, WalletBalances, Eip712TxData, ZKTransactionReceiptLog } from './types';
import { IZkSyncABI } from './contracts/IZkSyncStateTransition';
import { IBridgehubABI } from './contracts/IBridgehub';
import { IERC20ABI } from './contracts/IERC20';
import { Abi as IL1SharedBridgeABI } from './contracts/IL1SharedBridge';
import { IL2BridgeABI } from './contracts/IL2Bridge';
import type { Web3ZKsyncL1 } from './web3zksync-l1';
interface TxSender {
    getAddress(): Promise<Address>;
}
export declare class AdapterL1 implements TxSender {
    protected _contextL2(): Web3ZKsyncL2;
    protected _contextL1(): Web3ZKsyncL1;
    getMainContract(returnFormat?: web3Types.DataFormat): Promise<Web3.Contract<typeof IZkSyncABI>>;
    getBridgehubContract(returnFormat?: web3Types.DataFormat): Promise<Web3.Contract<typeof IBridgehubABI>>;
    getL1BridgeContracts(returnFormat?: web3Types.DataFormat): Promise<{
        erc20: Web3.Contract<typeof IERC20ABI>;
        weth: Web3.Contract<typeof IERC20ABI>;
        shared: Web3.Contract<typeof IL1SharedBridgeABI>;
    }>;
    getBaseToken(): Promise<Address>;
    isETHBasedChain(): Promise<boolean>;
    getBalanceL1(token?: Address, blockTag?: web3Types.BlockNumberOrTag): Promise<bigint>;
    getAllowanceL1(token: Address, bridgeAddress?: Address, blockTag?: web3Types.BlockNumberOrTag): Promise<bigint>;
    l2TokenAddress(token: Address): Promise<string>;
    approveERC20(token: Address, amount: web3Types.Numbers, overrides?: TransactionOverrides & {
        bridgeAddress?: Address;
    }): Promise<{
        readonly transactionHash: string;
        readonly transactionIndex: bigint;
        readonly blockHash: string;
        readonly blockNumber: bigint;
        readonly from: web3Types.Address;
        readonly to: web3Types.Address;
        readonly cumulativeGasUsed: bigint;
        readonly gasUsed: bigint;
        readonly effectiveGasPrice?: bigint | undefined;
        readonly contractAddress?: web3Types.Address | undefined;
        readonly logs: {
            readonly id?: string | undefined;
            readonly removed?: boolean | undefined;
            readonly logIndex?: bigint | undefined;
            readonly transactionIndex?: bigint | undefined;
            readonly transactionHash?: string | undefined;
            readonly blockHash?: string | undefined;
            readonly blockNumber?: bigint | undefined;
            readonly address?: web3Types.Address | undefined;
            readonly data?: string | undefined;
            readonly topics?: string[] | undefined;
        }[];
        readonly logsBloom: string;
        readonly root: string;
        readonly status: bigint;
        readonly type?: bigint | undefined;
        events?: {
            [x: string]: {
                readonly event: string;
                readonly id?: string | undefined;
                readonly logIndex?: bigint | undefined;
                readonly transactionIndex?: bigint | undefined;
                readonly transactionHash?: web3Types.HexString32Bytes | undefined;
                readonly blockHash?: web3Types.HexString32Bytes | undefined;
                readonly blockNumber?: bigint | undefined;
                readonly address: string;
                readonly topics: web3Types.HexString[];
                readonly data: web3Types.HexString;
                readonly raw?: {
                    data: string;
                    topics: unknown[];
                } | undefined;
                readonly returnValues: {
                    [x: string]: unknown;
                };
                readonly signature?: web3Types.HexString | undefined;
            };
        } | undefined;
    }>;
    getBaseCost(params: {
        gasLimit: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        gasPrice?: web3Types.Numbers;
        chainId?: web3Types.Numbers;
    }): Promise<bigint>;
    getDepositAllowanceParams(token: Address, amount: web3Types.Numbers): Promise<{
        token: Address;
        allowance: web3Types.Numbers;
    }[]>;
    deposit(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        approveERC20?: boolean;
        approveBaseERC20?: boolean;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
        approveOverrides?: TransactionOverrides;
        approveBaseOverrides?: TransactionOverrides;
        customBridgeData?: web3Types.Bytes;
    }): Promise<PriorityOpResponse>;
    _depositNonBaseTokenToNonETHBasedChain(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        approveERC20?: boolean;
        approveBaseERC20?: boolean;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
        approveOverrides?: TransactionOverrides;
        approveBaseOverrides?: TransactionOverrides;
        customBridgeData?: web3Types.Bytes;
    }): Promise<PriorityOpResponse>;
    _depositBaseTokenToNonETHBasedChain(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        approveERC20?: boolean;
        approveBaseERC20?: boolean;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
        approveOverrides?: TransactionOverrides;
        approveBaseOverrides?: TransactionOverrides;
        customBridgeData?: web3Types.Bytes;
    }): Promise<PriorityOpResponse>;
    _depositETHToNonETHBasedChain(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        approveERC20?: boolean;
        approveBaseERC20?: boolean;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
        approveOverrides?: TransactionOverrides;
        approveBaseOverrides?: TransactionOverrides;
        customBridgeData?: web3Types.Bytes;
    }): Promise<PriorityOpResponse>;
    _depositTokenToETHBasedChain(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        approveERC20?: boolean;
        approveBaseERC20?: boolean;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
        approveOverrides?: TransactionOverrides;
        approveBaseOverrides?: TransactionOverrides;
        customBridgeData?: web3Types.Bytes;
    }): Promise<PriorityOpResponse>;
    _depositETHToETHBasedChain(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        approveERC20?: boolean;
        approveBaseERC20?: boolean;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
        approveOverrides?: TransactionOverrides;
        approveBaseOverrides?: TransactionOverrides;
        customBridgeData?: web3Types.Bytes;
    }): Promise<PriorityOpResponse>;
    estimateGasDeposit(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        customBridgeData?: web3Types.Bytes;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<bigint>;
    getDepositTx(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<any>;
    _getDepositNonBaseTokenToNonETHBasedChainTx(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        tx: Web3.eth.contract.PayableMethodObject<[{
            chainId: web3Types.MatchPrimitiveType<"uint256", unknown>;
            mintValue: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2Value: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2GasLimit: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2GasPerPubdataByteLimit: web3Types.MatchPrimitiveType<"uint256", unknown>;
            refundRecipient: string;
            secondBridgeAddress: string;
            secondBridgeValue: web3Types.MatchPrimitiveType<"uint256", unknown>;
            secondBridgeCalldata: web3Types.MatchPrimitiveType<"bytes", unknown>;
        }], web3Types.MatchPrimitiveType<"bytes32", unknown>>;
        overrides: TransactionOverrides;
        mintValue: bigint;
    }>;
    _getDepositBaseTokenOnNonETHBasedChainTx(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        tx: {
            token: Address;
            amount: web3Types.Numbers;
            to: Address;
            operatorTip: web3Types.Numbers;
            bridgeAddress?: Address;
            l2GasLimit: web3Types.Numbers;
            gasPerPubdataByte: web3Types.Numbers;
            customBridgeData?: web3Types.Bytes;
            refundRecipient?: Address;
            overrides: TransactionOverrides;
            contractAddress: string;
            calldata: string;
            mintValue: bigint;
            l2Value: web3Types.Numbers;
        };
        mintValue: bigint;
    }>;
    _getDepositETHOnNonETHBasedChainTx(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        tx: Web3.eth.contract.PayableMethodObject<[{
            chainId: web3Types.MatchPrimitiveType<"uint256", unknown>;
            mintValue: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2Value: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2GasLimit: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2GasPerPubdataByteLimit: web3Types.MatchPrimitiveType<"uint256", unknown>;
            refundRecipient: string;
            secondBridgeAddress: string;
            secondBridgeValue: web3Types.MatchPrimitiveType<"uint256", unknown>;
            secondBridgeCalldata: web3Types.MatchPrimitiveType<"bytes", unknown>;
        }], web3Types.MatchPrimitiveType<"bytes32", unknown>>;
        overrides: TransactionOverrides;
        mintValue: bigint;
    }>;
    _getDepositTokenOnETHBasedChainTx(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        tx: PayableMethodObject;
        overrides: TransactionOverrides;
    }>;
    _getDepositETHOnETHBasedChainTx(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        token: Address;
        amount: web3Types.Numbers;
        to: Address;
        operatorTip: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit: web3Types.Numbers;
        gasPerPubdataByte: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides: TransactionOverrides;
        contractAddress: string;
        calldata: string;
        mintValue: web3Types.Numbers;
        l2Value: web3Types.Numbers;
    }>;
    _getDepositTxWithDefaults(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        token: Address;
        amount: web3Types.Numbers;
        to: Address;
        operatorTip: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit: web3Types.Numbers;
        gasPerPubdataByte: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides: TransactionOverrides;
    }>;
    _getL2GasLimit(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<web3Types.Numbers>;
    _getL2GasLimitFromCustomBridge(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        operatorTip?: web3Types.Numbers;
        bridgeAddress?: Address;
        l2GasLimit?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        customBridgeData?: web3Types.Bytes;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<web3Types.Numbers>;
    getFullRequiredDepositFee(transaction: {
        token: Address;
        to?: Address;
        bridgeAddress?: Address;
        customBridgeData?: web3Types.Bytes;
        gasPerPubdataByte?: web3Types.Numbers;
        overrides?: TransactionOverrides;
    }): Promise<FullDepositFee>;
    getPriorityOpConfirmation(txHash: string, index?: number): Promise<{
        l1BatchNumber: string | number | bigint;
        l2MessageIndex: web3Types.Numbers;
        l2TxNumberInBlock: string | number | bigint;
        proof: string[];
    }>;
    _getWithdrawalLog(withdrawalHash: web3Types.Bytes, index?: number): Promise<{
        log: ZKTransactionReceiptLog;
        l1BatchTxId: Numbers;
    }>;
    _getWithdrawalL2ToL1Log(withdrawalHash: web3Types.Bytes, index?: number): Promise<{
        l2ToL1LogIndex?: undefined;
        l2ToL1Log?: undefined;
    } | {
        l2ToL1LogIndex: number;
        l2ToL1Log: {
            blockNumber: string | number | bigint;
            blockHash: string;
            l1BatchNumber: string | number | bigint;
            transactionIndex: string | number | bigint;
            shardId: string | number | bigint;
            isService: boolean;
            sender: string;
            key: string;
            value: string;
            transactionHash: string;
            logIndex: string | number | bigint;
        };
    }>;
    finalizeWithdrawalParams(withdrawalHash: web3Types.Bytes, index?: number): Promise<FinalizeWithdrawalParams>;
    finalizeWithdrawal(withdrawalHash: web3Types.Bytes, index?: number, overrides?: TransactionOverrides): Promise<{
        readonly transactionHash: string;
        readonly transactionIndex: bigint;
        readonly blockHash: string;
        readonly blockNumber: bigint;
        readonly from: web3Types.Address;
        readonly to: web3Types.Address;
        readonly cumulativeGasUsed: bigint;
        readonly gasUsed: bigint;
        readonly effectiveGasPrice?: bigint | undefined;
        readonly contractAddress?: web3Types.Address | undefined;
        readonly logs: {
            readonly id?: string | undefined;
            readonly removed?: boolean | undefined;
            readonly logIndex?: bigint | undefined;
            readonly transactionIndex?: bigint | undefined;
            readonly transactionHash?: string | undefined;
            readonly blockHash?: string | undefined;
            readonly blockNumber?: bigint | undefined;
            readonly address?: web3Types.Address | undefined;
            readonly data?: string | undefined;
            readonly topics?: string[] | undefined;
        }[];
        readonly logsBloom: string;
        readonly root: string;
        readonly status: bigint;
        readonly type?: bigint | undefined;
        events?: {
            [x: string]: {
                readonly event: string;
                readonly id?: string | undefined;
                readonly logIndex?: bigint | undefined;
                readonly transactionIndex?: bigint | undefined;
                readonly transactionHash?: web3Types.HexString32Bytes | undefined;
                readonly blockHash?: web3Types.HexString32Bytes | undefined;
                readonly blockNumber?: bigint | undefined;
                readonly address: string;
                readonly topics: web3Types.HexString[];
                readonly data: web3Types.HexString;
                readonly raw?: {
                    data: string;
                    topics: unknown[];
                } | undefined;
                readonly returnValues: {
                    [x: string]: unknown;
                };
                readonly signature?: web3Types.HexString | undefined;
            };
        } | undefined;
    }>;
    isWithdrawalFinalized(withdrawalHash: web3Types.Bytes, index?: number): Promise<boolean>;
    claimFailedDeposit(depositHash: web3Types.Bytes, overrides?: TransactionOverrides): Promise<TransactionReceipt>;
    requestExecute(transaction: {
        contractAddress: Address;
        calldata: string;
        l2GasLimit?: web3Types.Numbers;
        mintValue?: web3Types.Numbers;
        l2Value?: web3Types.Numbers;
        factoryDeps?: web3Types.Bytes[];
        operatorTip?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<PriorityOpResponse>;
    signAndSend(tx: Transaction, _context?: Web3ZKsyncL1 | Web3ZKsyncL2): Promise<PriorityOpResponse>;
    signTransaction(tx: Transaction): Promise<string>;
    sendRawTransaction(signedTx: string): Promise<TransactionHash>;
    estimateGasRequestExecute(transaction: {
        contractAddress: Address;
        calldata: string;
        l2GasLimit?: web3Types.Numbers;
        mintValue?: web3Types.Numbers;
        l2Value?: web3Types.Numbers;
        factoryDeps?: web3Types.Bytes[];
        operatorTip?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<bigint>;
    getRequestExecuteAllowanceParams(transaction: {
        contractAddress: Address;
        calldata: string;
        l2GasLimit?: web3Types.Numbers;
        l2Value?: web3Types.Numbers;
        factoryDeps?: web3Types.Bytes[];
        operatorTip?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        token: Address;
        allowance: web3Types.Numbers;
    }>;
    getRequestExecuteContractMethod(transaction: {
        contractAddress: Address;
        calldata: string;
        l2GasLimit?: web3Types.Numbers;
        mintValue?: web3Types.Numbers;
        l2Value?: web3Types.Numbers;
        factoryDeps?: web3Types.Bytes[];
        operatorTip?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<{
        method: Web3.eth.contract.PayableMethodObject<[{
            chainId: web3Types.MatchPrimitiveType<"uint256", unknown>;
            mintValue: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2Contract: string;
            l2Value: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2Calldata: web3Types.MatchPrimitiveType<"bytes", unknown>;
            l2GasLimit: web3Types.MatchPrimitiveType<"uint256", unknown>;
            l2GasPerPubdataByteLimit: web3Types.MatchPrimitiveType<"uint256", unknown>;
            factoryDeps: web3Types.Bytes[];
            refundRecipient: string;
        }], web3Types.MatchPrimitiveType<"bytes32", unknown>>;
        overrides: TransactionOverrides;
    }>;
    getRequestExecuteTx(transaction: {
        contractAddress: Address;
        calldata: string;
        l2GasLimit?: web3Types.Numbers;
        mintValue?: web3Types.Numbers;
        l2Value?: web3Types.Numbers;
        factoryDeps?: web3Types.Bytes[];
        operatorTip?: web3Types.Numbers;
        gasPerPubdataByte?: web3Types.Numbers;
        refundRecipient?: Address;
        overrides?: TransactionOverrides;
    }): Promise<web3Types.TransactionCall>;
    populateTransaction(tx: Transaction): Promise<Transaction | Eip712TxData>;
    getAddress(): string;
}
export declare class AdapterL2 implements TxSender {
    _contextL2(): Web3ZKsyncL2;
    _eip712Signer(): Promise<EIP712Signer>;
    getBalance(token?: Address, blockTag?: web3Types.BlockNumberOrTag): Promise<bigint>;
    getAllBalances(): Promise<WalletBalances>;
    getDeploymentNonce(): Promise<bigint>;
    getL2BridgeContracts(): Promise<{
        erc20: Web3.Contract<typeof IL2BridgeABI>;
        weth: Web3.Contract<typeof IL2BridgeABI>;
        shared: Web3.Contract<typeof IL2BridgeABI>;
    }>;
    withdraw(transaction: {
        token: Address;
        amount: web3Types.Numbers;
        to?: Address;
        bridgeAddress?: Address;
        paymasterParams?: PaymasterParams;
        overrides?: TransactionOverrides;
    }): Promise<PriorityOpResponse>;
    signTransaction(tx: Transaction): Promise<string>;
    sendRawTransaction(signedTx: string): Promise<TransactionHash>;
    transferTx(transaction: {
        to: Address;
        amount: web3Types.Numbers;
        token?: Address;
        paymasterParams?: PaymasterParams;
        overrides?: TransactionOverrides;
    }): Promise<Transaction>;
    getAddress(): string;
    populateTransaction(tx: Transaction): Promise<Transaction | Eip712TxData>;
}
export {};
//# sourceMappingURL=adapters.d.ts.map
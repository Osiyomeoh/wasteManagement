"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTypedData = exports.createAccessList = exports.getFeeHistory = exports.getProof = exports.getChainId = exports.getLogs = exports.estimateGas = exports.call = exports.signTransaction = exports.sign = exports.sendSignedTransaction = exports.sendTransaction = exports.getTransactionCount = exports.getTransactionReceipt = exports.getTransactionFromBlock = exports.getPendingTransactions = exports.getTransaction = exports.getUncle = exports.getBlockUncleCount = exports.getBlockTransactionCount = exports.getBlock = exports.getCode = exports.getStorageAt = exports.getBalance = exports.getBlockNumber = exports.getMaxPriorityFeePerGas = exports.getGasPrice = exports.getHashRate = exports.isMining = exports.getCoinbase = exports.isSyncing = exports.getProtocolVersion = void 0;
const web3_types_1 = require("web3-types");
const web3_core_1 = require("web3-core");
const web3_utils_1 = require("web3-utils");
const web3_eth_accounts_1 = require("web3-eth-accounts");
const web3_validator_1 = require("web3-validator");
const web3_errors_1 = require("web3-errors");
const web3_rpc_methods_1 = require("web3-rpc-methods");
const decode_signed_transaction_js_1 = require("./utils/decode_signed_transaction.js");
const schemas_js_1 = require("./schemas.js");
const transaction_builder_js_1 = require("./utils/transaction_builder.js");
const format_transaction_js_1 = require("./utils/format_transaction.js");
const try_send_transaction_js_1 = require("./utils/try_send_transaction.js");
const wait_for_transaction_receipt_js_1 = require("./utils/wait_for_transaction_receipt.js");
const constants_js_1 = require("./constants.js");
const send_tx_helper_js_1 = require("./utils/send_tx_helper.js");
const getProtocolVersion = async (web3Context) => web3_rpc_methods_1.ethRpcMethods.getProtocolVersion(web3Context.requestManager);
exports.getProtocolVersion = getProtocolVersion;
const isSyncing = async (web3Context) => web3_rpc_methods_1.ethRpcMethods.getSyncing(web3Context.requestManager);
exports.isSyncing = isSyncing;
const getCoinbase = async (web3Context) => web3_rpc_methods_1.ethRpcMethods.getCoinbase(web3Context.requestManager);
exports.getCoinbase = getCoinbase;
const isMining = async (web3Context) => web3_rpc_methods_1.ethRpcMethods.getMining(web3Context.requestManager);
exports.isMining = isMining;
async function getHashRate(web3Context, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.getHashRate(web3Context.requestManager);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getHashRate = getHashRate;
async function getGasPrice(web3Context, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.getGasPrice(web3Context.requestManager);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getGasPrice = getGasPrice;
async function getMaxPriorityFeePerGas(web3Context, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.getMaxPriorityFeePerGas(web3Context.requestManager);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getMaxPriorityFeePerGas = getMaxPriorityFeePerGas;
async function getBlockNumber(web3Context, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.getBlockNumber(web3Context.requestManager);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getBlockNumber = getBlockNumber;
async function getBalance(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getBalance(web3Context.requestManager, address, blockNumberFormatted);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getBalance = getBalance;
async function getStorageAt(web3Context, address, storageSlot, blockNumber = web3Context.defaultBlock, returnFormat) {
    const storageSlotFormatted = (0, web3_utils_1.format)({ format: 'uint' }, storageSlot, web3_types_1.ETH_DATA_FORMAT);
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getStorageAt(web3Context.requestManager, address, storageSlotFormatted, blockNumberFormatted);
    return (0, web3_utils_1.format)({ format: 'bytes' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getStorageAt = getStorageAt;
async function getCode(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getCode(web3Context.requestManager, address, blockNumberFormatted);
    return (0, web3_utils_1.format)({ format: 'bytes' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getCode = getCode;
async function getBlock(web3Context, block = web3Context.defaultBlock, hydrated = false, returnFormat) {
    let response;
    if ((0, web3_validator_1.isBytes)(block)) {
        const blockHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getBlockByHash(web3Context.requestManager, blockHashFormatted, hydrated);
    }
    else {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
            ? block
            : (0, web3_utils_1.format)({ format: 'uint' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getBlockByNumber(web3Context.requestManager, blockNumberFormatted, hydrated);
    }
    const res = (0, web3_utils_1.format)(schemas_js_1.blockSchema, response, returnFormat ?? web3Context.defaultReturnFormat);
    if (!(0, web3_validator_1.isNullish)(res)) {
        const result = {
            ...res,
            transactions: res.transactions ?? [],
        };
        return result;
    }
    return res;
}
exports.getBlock = getBlock;
async function getBlockTransactionCount(web3Context, block = web3Context.defaultBlock, returnFormat) {
    let response;
    if ((0, web3_validator_1.isBytes)(block)) {
        const blockHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getBlockTransactionCountByHash(web3Context.requestManager, blockHashFormatted);
    }
    else {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
            ? block
            : (0, web3_utils_1.format)({ format: 'uint' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getBlockTransactionCountByNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getBlockTransactionCount = getBlockTransactionCount;
async function getBlockUncleCount(web3Context, block = web3Context.defaultBlock, returnFormat) {
    let response;
    if ((0, web3_validator_1.isBytes)(block)) {
        const blockHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getUncleCountByBlockHash(web3Context.requestManager, blockHashFormatted);
    }
    else {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
            ? block
            : (0, web3_utils_1.format)({ format: 'uint' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getUncleCountByBlockNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getBlockUncleCount = getBlockUncleCount;
async function getUncle(web3Context, block = web3Context.defaultBlock, uncleIndex, returnFormat) {
    const uncleIndexFormatted = (0, web3_utils_1.format)({ format: 'uint' }, uncleIndex, web3_types_1.ETH_DATA_FORMAT);
    let response;
    if ((0, web3_validator_1.isBytes)(block)) {
        const blockHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getUncleByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, uncleIndexFormatted);
    }
    else {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
            ? block
            : (0, web3_utils_1.format)({ format: 'uint' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getUncleByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, uncleIndexFormatted);
    }
    return (0, web3_utils_1.format)(schemas_js_1.blockSchema, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getUncle = getUncle;
async function getTransaction(web3Context, transactionHash, returnFormat = web3Context.defaultReturnFormat) {
    const transactionHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, transactionHash, web3_types_1.DEFAULT_RETURN_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getTransactionByHash(web3Context.requestManager, transactionHashFormatted);
    return (0, web3_validator_1.isNullish)(response)
        ? response
        : (0, format_transaction_js_1.formatTransaction)(response, returnFormat, {
            fillInputAndData: true,
        });
}
exports.getTransaction = getTransaction;
async function getPendingTransactions(web3Context, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.getPendingTransactions(web3Context.requestManager);
    return response.map(transaction => (0, format_transaction_js_1.formatTransaction)(transaction, returnFormat ?? web3Context.defaultReturnFormat, {
        fillInputAndData: true,
    }));
}
exports.getPendingTransactions = getPendingTransactions;
async function getTransactionFromBlock(web3Context, block = web3Context.defaultBlock, transactionIndex, returnFormat) {
    const transactionIndexFormatted = (0, web3_utils_1.format)({ format: 'uint' }, transactionIndex, web3_types_1.ETH_DATA_FORMAT);
    let response;
    if ((0, web3_validator_1.isBytes)(block)) {
        const blockHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getTransactionByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, transactionIndexFormatted);
    }
    else {
        const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(block)
            ? block
            : (0, web3_utils_1.format)({ format: 'uint' }, block, web3_types_1.ETH_DATA_FORMAT);
        response = await web3_rpc_methods_1.ethRpcMethods.getTransactionByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, transactionIndexFormatted);
    }
    return (0, web3_validator_1.isNullish)(response)
        ? response
        : (0, format_transaction_js_1.formatTransaction)(response, returnFormat ?? web3Context.defaultReturnFormat, {
            fillInputAndData: true,
        });
}
exports.getTransactionFromBlock = getTransactionFromBlock;
async function getTransactionReceipt(web3Context, transactionHash, returnFormat) {
    const transactionHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, transactionHash, web3_types_1.DEFAULT_RETURN_FORMAT);
    let response;
    try {
        response = await web3_rpc_methods_1.ethRpcMethods.getTransactionReceipt(web3Context.requestManager, transactionHashFormatted);
    }
    catch (error) {
        if (typeof error === 'object' && !(0, web3_validator_1.isNullish)(error) && 'message' in error && error.message === 'transaction indexing is in progress') {
            console.warn('Transaction indexing is in progress.');
        }
        else {
            throw error;
        }
    }
    return (0, web3_validator_1.isNullish)(response)
        ? response
        : ((0, web3_utils_1.format)(schemas_js_1.transactionReceiptSchema, response, returnFormat ?? web3Context.defaultReturnFormat));
}
exports.getTransactionReceipt = getTransactionReceipt;
async function getTransactionCount(web3Context, address, blockNumber = web3Context.defaultBlock, returnFormat) {
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getTransactionCount(web3Context.requestManager, address, blockNumberFormatted);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getTransactionCount = getTransactionCount;
function sendTransaction(web3Context, transactionObj, returnFormat, options = { checkRevertBeforeSending: true }, transactionMiddleware) {
    const promiEvent = new web3_core_1.Web3PromiEvent((resolve, reject) => {
        setImmediate(() => {
            (async () => {
                const sendTxHelper = new send_tx_helper_js_1.SendTxHelper({
                    web3Context,
                    promiEvent,
                    options,
                    returnFormat,
                });
                let transaction = { ...transactionObj };
                if (!(0, web3_validator_1.isNullish)(transactionMiddleware)) {
                    transaction = await transactionMiddleware.processTransaction(transaction);
                }
                let transactionFormatted = (0, format_transaction_js_1.formatTransaction)({
                    ...transaction,
                    from: (0, transaction_builder_js_1.getTransactionFromOrToAttr)('from', web3Context, transaction),
                    to: (0, transaction_builder_js_1.getTransactionFromOrToAttr)('to', web3Context, transaction),
                }, web3_types_1.ETH_DATA_FORMAT);
                try {
                    transactionFormatted = await sendTxHelper.populateGasPrice({
                        transaction,
                        transactionFormatted,
                    });
                    await sendTxHelper.checkRevertBeforeSending(transactionFormatted);
                    sendTxHelper.emitSending(transactionFormatted);
                    let wallet;
                    if (web3Context.wallet && !(0, web3_validator_1.isNullish)(transactionFormatted.from)) {
                        wallet = web3Context.wallet.get(transactionFormatted.from);
                    }
                    const transactionHash = await sendTxHelper.signAndSend({
                        wallet,
                        tx: transactionFormatted,
                    });
                    const transactionHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, transactionHash, returnFormat ?? web3Context.defaultReturnFormat);
                    sendTxHelper.emitSent(transactionFormatted);
                    sendTxHelper.emitTransactionHash(transactionHashFormatted);
                    const transactionReceipt = await (0, wait_for_transaction_receipt_js_1.waitForTransactionReceipt)(web3Context, transactionHash, returnFormat ?? web3Context.defaultReturnFormat);
                    const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents((0, web3_utils_1.format)(schemas_js_1.transactionReceiptSchema, transactionReceipt, returnFormat ?? web3Context.defaultReturnFormat));
                    sendTxHelper.emitReceipt(transactionReceiptFormatted);
                    resolve(await sendTxHelper.handleResolve({
                        receipt: transactionReceiptFormatted,
                        tx: transactionFormatted,
                    }));
                    sendTxHelper.emitConfirmation({
                        receipt: transactionReceiptFormatted,
                        transactionHash,
                    });
                }
                catch (error) {
                    reject(await sendTxHelper.handleError({
                        error,
                        tx: transactionFormatted,
                    }));
                }
            })();
        });
    });
    return promiEvent;
}
exports.sendTransaction = sendTransaction;
function sendSignedTransaction(web3Context, signedTransaction, returnFormat, options = { checkRevertBeforeSending: true }) {
    const promiEvent = new web3_core_1.Web3PromiEvent((resolve, reject) => {
        setImmediate(() => {
            (async () => {
                const sendTxHelper = new send_tx_helper_js_1.SendTxHelper({
                    web3Context,
                    promiEvent,
                    options,
                    returnFormat,
                });
                const signedTransactionFormattedHex = (0, web3_utils_1.format)({ format: 'bytes' }, signedTransaction, web3_types_1.ETH_DATA_FORMAT);
                const unSerializedTransaction = web3_eth_accounts_1.TransactionFactory.fromSerializedData((0, web3_utils_1.bytesToUint8Array)((0, web3_utils_1.hexToBytes)(signedTransactionFormattedHex)));
                const unSerializedTransactionWithFrom = {
                    ...unSerializedTransaction.toJSON(),
                    from: unSerializedTransaction.getSenderAddress().toString(),
                };
                try {
                    const { v, r, s, ...txWithoutSigParams } = unSerializedTransactionWithFrom;
                    await sendTxHelper.checkRevertBeforeSending(txWithoutSigParams);
                    sendTxHelper.emitSending(signedTransactionFormattedHex);
                    const transactionHash = await (0, try_send_transaction_js_1.trySendTransaction)(web3Context, async () => web3_rpc_methods_1.ethRpcMethods.sendRawTransaction(web3Context.requestManager, signedTransactionFormattedHex));
                    sendTxHelper.emitSent(signedTransactionFormattedHex);
                    const transactionHashFormatted = (0, web3_utils_1.format)({ format: 'bytes32' }, transactionHash, returnFormat ?? web3Context.defaultReturnFormat);
                    sendTxHelper.emitTransactionHash(transactionHashFormatted);
                    const transactionReceipt = await (0, wait_for_transaction_receipt_js_1.waitForTransactionReceipt)(web3Context, transactionHash, returnFormat ?? web3Context.defaultReturnFormat);
                    const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents((0, web3_utils_1.format)(schemas_js_1.transactionReceiptSchema, transactionReceipt, returnFormat ?? web3Context.defaultReturnFormat));
                    sendTxHelper.emitReceipt(transactionReceiptFormatted);
                    resolve(await sendTxHelper.handleResolve({
                        receipt: transactionReceiptFormatted,
                        tx: unSerializedTransactionWithFrom,
                    }));
                    sendTxHelper.emitConfirmation({
                        receipt: transactionReceiptFormatted,
                        transactionHash,
                    });
                }
                catch (error) {
                    reject(await sendTxHelper.handleError({
                        error,
                        tx: unSerializedTransactionWithFrom,
                    }));
                }
            })();
        });
    });
    return promiEvent;
}
exports.sendSignedTransaction = sendSignedTransaction;
async function sign(web3Context, message, addressOrIndex, returnFormat = web3Context.defaultReturnFormat) {
    const messageFormatted = (0, web3_utils_1.format)({ format: 'bytes' }, message, web3_types_1.DEFAULT_RETURN_FORMAT);
    if (web3Context.wallet?.get(addressOrIndex)) {
        const wallet = web3Context.wallet.get(addressOrIndex);
        const signed = wallet.sign(messageFormatted);
        return (0, web3_utils_1.format)(schemas_js_1.SignatureObjectSchema, signed, returnFormat);
    }
    if (typeof addressOrIndex === 'number') {
        throw new web3_errors_1.SignatureError(message, 'RPC method "eth_sign" does not support index signatures');
    }
    const response = await web3_rpc_methods_1.ethRpcMethods.sign(web3Context.requestManager, addressOrIndex, messageFormatted);
    return (0, web3_utils_1.format)({ format: 'bytes' }, response, returnFormat);
}
exports.sign = sign;
async function signTransaction(web3Context, transaction, returnFormat = web3Context.defaultReturnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.signTransaction(web3Context.requestManager, (0, format_transaction_js_1.formatTransaction)(transaction, web3_types_1.ETH_DATA_FORMAT));
    return (0, web3_validator_1.isString)(response)
        ? (0, decode_signed_transaction_js_1.decodeSignedTransaction)(response, returnFormat, {
            fillInputAndData: true,
        })
        : {
            raw: (0, web3_utils_1.format)({ format: 'bytes' }, response.raw, returnFormat),
            tx: (0, format_transaction_js_1.formatTransaction)(response.tx, returnFormat, {
                fillInputAndData: true,
            }),
        };
}
exports.signTransaction = signTransaction;
async function call(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat = web3Context.defaultReturnFormat) {
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.call(web3Context.requestManager, (0, format_transaction_js_1.formatTransaction)(transaction, web3_types_1.ETH_DATA_FORMAT), blockNumberFormatted);
    return (0, web3_utils_1.format)({ format: 'bytes' }, response, returnFormat);
}
exports.call = call;
async function estimateGas(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
    const transactionFormatted = (0, format_transaction_js_1.formatTransaction)(transaction, web3_types_1.ETH_DATA_FORMAT);
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.estimateGas(web3Context.requestManager, transactionFormatted, blockNumberFormatted);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.estimateGas = estimateGas;
async function getLogs(web3Context, filter, returnFormat) {
    let { toBlock, fromBlock } = filter;
    if (!(0, web3_validator_1.isNullish)(toBlock)) {
        if (typeof toBlock === 'number' || typeof toBlock === 'bigint') {
            toBlock = (0, web3_utils_1.numberToHex)(toBlock);
        }
    }
    if (!(0, web3_validator_1.isNullish)(fromBlock)) {
        if (typeof fromBlock === 'number' || typeof fromBlock === 'bigint') {
            fromBlock = (0, web3_utils_1.numberToHex)(fromBlock);
        }
    }
    const formattedFilter = { ...filter, fromBlock, toBlock };
    const response = await web3_rpc_methods_1.ethRpcMethods.getLogs(web3Context.requestManager, formattedFilter);
    const result = response.map(res => {
        if (typeof res === 'string') {
            return res;
        }
        return (0, web3_utils_1.format)(schemas_js_1.logSchema, res, returnFormat ?? web3Context.defaultReturnFormat);
    });
    return result;
}
exports.getLogs = getLogs;
async function getChainId(web3Context, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.getChainId(web3Context.requestManager);
    return (0, web3_utils_1.format)({ format: 'uint' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getChainId = getChainId;
async function getProof(web3Context, address, storageKeys, blockNumber = web3Context.defaultBlock, returnFormat) {
    const storageKeysFormatted = storageKeys.map(storageKey => (0, web3_utils_1.format)({ format: 'bytes' }, storageKey, web3_types_1.ETH_DATA_FORMAT));
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getProof(web3Context.requestManager, address, storageKeysFormatted, blockNumberFormatted);
    return (0, web3_utils_1.format)(schemas_js_1.accountSchema, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getProof = getProof;
async function getFeeHistory(web3Context, blockCount, newestBlock = web3Context.defaultBlock, rewardPercentiles, returnFormat) {
    const blockCountFormatted = (0, web3_utils_1.format)({ format: 'uint' }, blockCount, web3_types_1.ETH_DATA_FORMAT);
    const newestBlockFormatted = (0, web3_validator_1.isBlockTag)(newestBlock)
        ? newestBlock
        : (0, web3_utils_1.format)({ format: 'uint' }, newestBlock, web3_types_1.ETH_DATA_FORMAT);
    const rewardPercentilesFormatted = (0, web3_utils_1.format)({
        type: 'array',
        items: {
            format: 'uint',
        },
    }, rewardPercentiles, constants_js_1.NUMBER_DATA_FORMAT);
    const response = await web3_rpc_methods_1.ethRpcMethods.getFeeHistory(web3Context.requestManager, blockCountFormatted, newestBlockFormatted, rewardPercentilesFormatted);
    return (0, web3_utils_1.format)(schemas_js_1.feeHistorySchema, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.getFeeHistory = getFeeHistory;
async function createAccessList(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
    const blockNumberFormatted = (0, web3_validator_1.isBlockTag)(blockNumber)
        ? blockNumber
        : (0, web3_utils_1.format)({ format: 'uint' }, blockNumber, web3_types_1.ETH_DATA_FORMAT);
    const response = (await web3_rpc_methods_1.ethRpcMethods.createAccessList(web3Context.requestManager, (0, format_transaction_js_1.formatTransaction)(transaction, web3_types_1.ETH_DATA_FORMAT), blockNumberFormatted));
    return (0, web3_utils_1.format)(schemas_js_1.accessListResultSchema, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.createAccessList = createAccessList;
async function signTypedData(web3Context, address, typedData, useLegacy, returnFormat) {
    const response = await web3_rpc_methods_1.ethRpcMethods.signTypedData(web3Context.requestManager, address, typedData, useLegacy);
    return (0, web3_utils_1.format)({ format: 'bytes' }, response, returnFormat ?? web3Context.defaultReturnFormat);
}
exports.signTypedData = signTypedData;
//# sourceMappingURL=rpc_method_wrappers.js.map
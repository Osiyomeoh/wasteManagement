"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendTxHelper = void 0;
const web3_types_1 = require("web3-types");
const web3_validator_1 = require("web3-validator");
const web3_errors_1 = require("web3-errors");
const web3_rpc_methods_1 = require("web3-rpc-methods");
const get_transaction_gas_pricing_js_1 = require("./get_transaction_gas_pricing.js");
const try_send_transaction_js_1 = require("./try_send_transaction.js");
const watch_transaction_for_confirmations_js_1 = require("./watch_transaction_for_confirmations.js");
const constants_js_1 = require("../constants.js");
const get_transaction_error_js_1 = require("./get_transaction_error.js");
const get_revert_reason_js_1 = require("./get_revert_reason.js");
const decoding_js_1 = require("./decoding.js");
class SendTxHelper {
    constructor({ options, web3Context, promiEvent, returnFormat, }) {
        this.options = {
            checkRevertBeforeSending: true,
        };
        this.options = options;
        this.web3Context = web3Context;
        this.promiEvent = promiEvent;
        this.returnFormat = returnFormat;
    }
    getReceiptWithEvents(data) {
        const result = { ...(data ?? {}) };
        if (this.options?.contractAbi && result.logs && result.logs.length > 0) {
            result.events = {};
            for (const log of result.logs) {
                const event = (0, decoding_js_1.decodeEventABI)(constants_js_1.ALL_EVENTS_ABI, log, this.options?.contractAbi, this.returnFormat);
                if (event.event) {
                    result.events[event.event] = event;
                }
            }
        }
        return result;
    }
    async checkRevertBeforeSending(tx) {
        if (this.options.checkRevertBeforeSending !== false) {
            let formatTx = tx;
            if ((0, web3_validator_1.isNullish)(tx.data) && (0, web3_validator_1.isNullish)(tx.input) && (0, web3_validator_1.isNullish)(tx.gas)) {
                formatTx = {
                    ...tx,
                    gas: 21000
                };
            }
            const reason = await (0, get_revert_reason_js_1.getRevertReason)(this.web3Context, formatTx, this.options.contractAbi);
            if (reason !== undefined) {
                throw await (0, get_transaction_error_js_1.getTransactionError)(this.web3Context, tx, undefined, undefined, this.options.contractAbi, reason);
            }
        }
    }
    emitSending(tx) {
        if (this.promiEvent.listenerCount('sending') > 0) {
            this.promiEvent.emit('sending', tx);
        }
    }
    async populateGasPrice({ transactionFormatted, transaction, }) {
        let result = transactionFormatted;
        if (!this.options?.ignoreGasPricing &&
            (0, web3_validator_1.isNullish)(transactionFormatted.gasPrice) &&
            ((0, web3_validator_1.isNullish)(transaction.maxPriorityFeePerGas) ||
                (0, web3_validator_1.isNullish)(transaction.maxFeePerGas))) {
            result = {
                ...transactionFormatted,
                ...(await (0, get_transaction_gas_pricing_js_1.getTransactionGasPricing)(transactionFormatted, this.web3Context, web3_types_1.ETH_DATA_FORMAT)),
            };
        }
        return result;
    }
    async signAndSend({ wallet, tx, }) {
        if (wallet) {
            const signedTransaction = await wallet.signTransaction(tx);
            return (0, try_send_transaction_js_1.trySendTransaction)(this.web3Context, async () => web3_rpc_methods_1.ethRpcMethods.sendRawTransaction(this.web3Context.requestManager, signedTransaction.rawTransaction), signedTransaction.transactionHash);
        }
        return (0, try_send_transaction_js_1.trySendTransaction)(this.web3Context, async () => web3_rpc_methods_1.ethRpcMethods.sendTransaction(this.web3Context.requestManager, tx));
    }
    emitSent(tx) {
        if (this.promiEvent.listenerCount('sent') > 0) {
            this.promiEvent.emit('sent', tx);
        }
    }
    emitTransactionHash(hash) {
        if (this.promiEvent.listenerCount('transactionHash') > 0) {
            this.promiEvent.emit('transactionHash', hash);
        }
    }
    emitReceipt(receipt) {
        if (this.promiEvent.listenerCount('receipt') > 0) {
            this.promiEvent.emit('receipt', receipt);
        }
    }
    async handleError({ error, tx }) {
        let _error = error;
        if (_error instanceof web3_errors_1.ContractExecutionError && this.web3Context.handleRevert) {
            _error = await (0, get_transaction_error_js_1.getTransactionError)(this.web3Context, tx, undefined, undefined, this.options?.contractAbi);
        }
        if ((_error instanceof web3_errors_1.InvalidResponseError ||
            _error instanceof web3_errors_1.ContractExecutionError ||
            _error instanceof web3_errors_1.TransactionRevertWithCustomError ||
            _error instanceof web3_errors_1.TransactionRevertedWithoutReasonError ||
            _error instanceof web3_errors_1.TransactionRevertInstructionError ||
            _error instanceof web3_errors_1.TransactionPollingTimeoutError) &&
            this.promiEvent.listenerCount('error') > 0) {
            this.promiEvent.emit('error', _error);
        }
        return _error;
    }
    emitConfirmation({ receipt, transactionHash, customTransactionReceiptSchema, }) {
        if (this.promiEvent.listenerCount('confirmation') > 0) {
            (0, watch_transaction_for_confirmations_js_1.watchTransactionForConfirmations)(this.web3Context, this.promiEvent, receipt, transactionHash, this.returnFormat, customTransactionReceiptSchema);
        }
    }
    async handleResolve({ receipt, tx }) {
        if (this.options?.transactionResolver) {
            return this.options?.transactionResolver(receipt);
        }
        if (receipt.status === BigInt(0)) {
            const error = await (0, get_transaction_error_js_1.getTransactionError)(this.web3Context, tx, receipt, undefined, this.options?.contractAbi);
            if (this.promiEvent.listenerCount('error') > 0) {
                this.promiEvent.emit('error', error);
            }
            throw error;
        }
        else {
            return receipt;
        }
    }
}
exports.SendTxHelper = SendTxHelper;
//# sourceMappingURL=send_tx_helper.js.map
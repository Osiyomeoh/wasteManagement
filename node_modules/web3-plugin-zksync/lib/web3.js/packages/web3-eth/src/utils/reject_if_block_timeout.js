"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rejectIfBlockTimeout = void 0;
const web3_utils_1 = require("web3-utils");
const web3_errors_1 = require("web3-errors");
const constants_js_1 = require("../constants.js");
const rpc_method_wrappers_js_1 = require("../rpc_method_wrappers.js");
function resolveByPolling(web3Context, starterBlockNumber, transactionHash) {
    const pollingInterval = web3Context.transactionPollingInterval;
    const [intervalId, promiseToError] = (0, web3_utils_1.rejectIfConditionAtInterval)(async () => {
        let lastBlockNumber;
        try {
            lastBlockNumber = await (0, rpc_method_wrappers_js_1.getBlockNumber)(web3Context, constants_js_1.NUMBER_DATA_FORMAT);
        }
        catch (error) {
            console.warn('An error happen while trying to get the block number', error);
            return undefined;
        }
        const numberOfBlocks = lastBlockNumber - starterBlockNumber;
        if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
            return new web3_errors_1.TransactionBlockTimeoutError({
                starterBlockNumber,
                numberOfBlocks,
                transactionHash,
            });
        }
        return undefined;
    }, pollingInterval);
    const clean = () => {
        clearInterval(intervalId);
    };
    return [promiseToError, { clean }];
}
async function resolveBySubscription(web3Context, starterBlockNumber, transactionHash) {
    let needToWatchLater = true;
    let subscription;
    let resourceCleaner;
    function revertToPolling(reject, previousError) {
        if (previousError) {
            console.warn('error happened at subscription. So revert to polling...', previousError);
        }
        resourceCleaner.clean();
        needToWatchLater = false;
        const [promiseToError, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
        resourceCleaner.clean = newResourceCleaner.clean;
        promiseToError.catch(error => reject(error));
    }
    try {
        subscription = (await web3Context.subscriptionManager?.subscribe('newHeads'));
        resourceCleaner = {
            clean: () => {
                if (subscription.id) {
                    web3Context.subscriptionManager
                        ?.removeSubscription(subscription)
                        .then(() => {
                    })
                        .catch(() => {
                    });
                }
            },
        };
    }
    catch (error) {
        return resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    const promiseToError = new Promise((_, reject) => {
        try {
            subscription.on('data', (lastBlockHeader) => {
                needToWatchLater = false;
                if (!lastBlockHeader?.number) {
                    return;
                }
                const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));
                if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
                    reject(new web3_errors_1.TransactionBlockTimeoutError({
                        starterBlockNumber,
                        numberOfBlocks,
                        transactionHash,
                    }));
                }
            });
            subscription.on('error', error => {
                revertToPolling(reject, error);
            });
        }
        catch (error) {
            revertToPolling(reject, error);
        }
        setTimeout(() => {
            if (needToWatchLater) {
                revertToPolling(reject);
            }
        }, web3Context.blockHeaderTimeout * 1000);
    });
    return [promiseToError, resourceCleaner];
}
async function rejectIfBlockTimeout(web3Context, transactionHash) {
    const { provider } = web3Context.requestManager;
    let callingRes;
    const starterBlockNumber = await (0, rpc_method_wrappers_js_1.getBlockNumber)(web3Context, constants_js_1.NUMBER_DATA_FORMAT);
    if (provider.supportsSubscriptions?.() &&
        web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {
        callingRes = await resolveBySubscription(web3Context, starterBlockNumber, transactionHash);
    }
    else {
        callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    return callingRes;
}
exports.rejectIfBlockTimeout = rejectIfBlockTimeout;
//# sourceMappingURL=reject_if_block_timeout.js.map
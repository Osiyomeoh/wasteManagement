"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareTransactionForSigning = void 0;
const web3_types_1 = require("web3-types");
const web3_utils_1 = require("web3-utils");
const web3_eth_accounts_1 = require("web3-eth-accounts");
const web3_validator_1 = require("web3-validator");
const validation_js_1 = require("../validation.js");
const format_transaction_js_1 = require("./format_transaction.js");
const transaction_builder_js_1 = require("./transaction_builder.js");
const getEthereumjsTxDataFromTransaction = (transaction) => ({
    nonce: transaction.nonce,
    gasPrice: transaction.gasPrice,
    gasLimit: transaction.gasLimit ?? transaction.gas,
    to: transaction.to,
    value: transaction.value,
    data: transaction.data ?? transaction.input,
    type: transaction.type,
    chainId: transaction.chainId,
    accessList: transaction.accessList,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
    maxFeePerGas: transaction.maxFeePerGas,
});
const getEthereumjsTransactionOptions = (transaction, web3Context) => {
    const hasTransactionSigningOptions = (!(0, web3_validator_1.isNullish)(transaction.chain) && !(0, web3_validator_1.isNullish)(transaction.hardfork)) ||
        !(0, web3_validator_1.isNullish)(transaction.common);
    let common;
    if (!hasTransactionSigningOptions) {
        if (web3Context.defaultCommon) {
            common = { ...web3Context.defaultCommon };
            if ((0, web3_validator_1.isNullish)(common.hardfork))
                common.hardfork = transaction.hardfork ?? web3Context.defaultHardfork;
            if ((0, web3_validator_1.isNullish)(common.baseChain))
                common.baseChain = web3Context.defaultChain;
        }
        else {
            common = web3_eth_accounts_1.Common.custom({
                name: 'custom-network',
                chainId: (0, web3_utils_1.toNumber)(transaction.chainId),
                networkId: !(0, web3_validator_1.isNullish)(transaction.networkId)
                    ? (0, web3_utils_1.toNumber)(transaction.networkId)
                    : undefined,
                defaultHardfork: transaction.hardfork ?? web3Context.defaultHardfork,
            }, {
                baseChain: web3Context.defaultChain,
            });
        }
    }
    else {
        const name = transaction?.common?.customChain?.name ?? transaction.chain ?? 'custom-network';
        const chainId = (0, web3_utils_1.toNumber)(transaction?.common?.customChain?.chainId ?? transaction?.chainId);
        const networkId = (0, web3_utils_1.toNumber)(transaction?.common?.customChain?.networkId ?? transaction?.networkId);
        const defaultHardfork = transaction?.common?.hardfork ?? transaction?.hardfork ?? web3Context.defaultHardfork;
        const baseChain = transaction.common?.baseChain ?? transaction.chain ?? web3Context.defaultChain;
        if (chainId && networkId && name) {
            common = web3_eth_accounts_1.Common.custom({
                name,
                chainId,
                networkId,
                defaultHardfork,
            }, {
                baseChain,
            });
        }
    }
    return { common };
};
const prepareTransactionForSigning = async (transaction, web3Context, privateKey, fillGasPrice = false, fillGasLimit = true) => {
    const populatedTransaction = (await (0, transaction_builder_js_1.transactionBuilder)({
        transaction,
        web3Context,
        privateKey,
        fillGasPrice,
        fillGasLimit,
    }));
    const formattedTransaction = (0, format_transaction_js_1.formatTransaction)(populatedTransaction, web3_types_1.ETH_DATA_FORMAT);
    (0, validation_js_1.validateTransactionForSigning)(formattedTransaction);
    return web3_eth_accounts_1.TransactionFactory.fromTxData(getEthereumjsTxDataFromTransaction(formattedTransaction), getEthereumjsTransactionOptions(formattedTransaction, web3Context));
};
exports.prepareTransactionForSigning = prepareTransactionForSigning;
//# sourceMappingURL=prepare_transaction_for_signing.js.map
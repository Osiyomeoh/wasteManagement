"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransactionError = void 0;
const web3_errors_1 = require("web3-errors");
const get_revert_reason_js_1 = require("./get_revert_reason.js");
async function getTransactionError(web3Context, transactionFormatted, transactionReceiptFormatted, receivedError, contractAbi, knownReason) {
    let _reason = knownReason;
    if (_reason === undefined) {
        if (receivedError !== undefined) {
            _reason = (0, get_revert_reason_js_1.parseTransactionError)(receivedError);
        }
        else if (web3Context.handleRevert && transactionFormatted !== undefined) {
            _reason = await (0, get_revert_reason_js_1.getRevertReason)(web3Context, transactionFormatted, contractAbi);
        }
    }
    let error;
    if (_reason === undefined) {
        error = new web3_errors_1.TransactionRevertedWithoutReasonError(transactionReceiptFormatted);
    }
    else if (typeof _reason === 'string') {
        error = new web3_errors_1.TransactionRevertInstructionError(_reason, undefined, transactionReceiptFormatted);
    }
    else if (_reason.customErrorName !== undefined &&
        _reason.customErrorDecodedSignature !== undefined &&
        _reason.customErrorArguments !== undefined) {
        const reasonWithCustomError = _reason;
        error = new web3_errors_1.TransactionRevertWithCustomError(reasonWithCustomError.reason, reasonWithCustomError.customErrorName, reasonWithCustomError.customErrorDecodedSignature, reasonWithCustomError.customErrorArguments, reasonWithCustomError.signature, transactionReceiptFormatted, reasonWithCustomError.data);
    }
    else {
        error = new web3_errors_1.TransactionRevertInstructionError(_reason.reason, _reason.signature, transactionReceiptFormatted, _reason.data);
    }
    return error;
}
exports.getTransactionError = getTransactionError;
//# sourceMappingURL=get_transaction_error.js.map
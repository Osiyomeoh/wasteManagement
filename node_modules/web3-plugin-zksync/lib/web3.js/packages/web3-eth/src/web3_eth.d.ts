import { SupportedProviders, Address, Bytes, FeeData, Filter, HexString32Bytes, HexString8Bytes, Numbers, BlockNumberOrTag, Transaction, TransactionCall, Web3EthExecutionAPI, TransactionWithFromLocalWalletIndex, TransactionWithToLocalWalletIndex, TransactionWithFromAndToLocalWalletIndex, TransactionForAccessList, DataFormat, DEFAULT_RETURN_FORMAT, Eip712TypedData } from 'web3-types';
import { Web3Context, Web3ContextInitOptions } from 'web3-core';
import { SendTransactionOptions, TransactionMiddleware } from './types.js';
import { LogsSubscription, NewPendingTransactionsSubscription, NewHeadsSubscription, SyncingSubscription } from './web3_subscriptions.js';
export type RegisteredSubscription = {
    logs: typeof LogsSubscription;
    newPendingTransactions: typeof NewPendingTransactionsSubscription;
    pendingTransactions: typeof NewPendingTransactionsSubscription;
    newHeads: typeof NewHeadsSubscription;
    newBlockHeaders: typeof NewHeadsSubscription;
    syncing: typeof SyncingSubscription;
};
export declare const registeredSubscriptions: {
    logs: typeof LogsSubscription;
    newPendingTransactions: typeof NewPendingTransactionsSubscription;
    newHeads: typeof NewHeadsSubscription;
    syncing: typeof SyncingSubscription;
    pendingTransactions: typeof NewPendingTransactionsSubscription;
    newBlockHeaders: typeof NewHeadsSubscription;
};
export declare class Web3Eth extends Web3Context<Web3EthExecutionAPI, RegisteredSubscription> {
    private transactionMiddleware?;
    constructor(providerOrContext?: SupportedProviders<any> | Web3ContextInitOptions | string);
    setTransactionMiddleware(transactionMiddleware: TransactionMiddleware): void;
    getTransactionMiddleware(): TransactionMiddleware | undefined;
    getProtocolVersion(): Promise<string>;
    isSyncing(): Promise<import("web3-types").SyncingStatusAPI>;
    getCoinbase(): Promise<string>;
    isMining(): Promise<boolean>;
    getHashrate<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getHashRate<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getGasPrice<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getMaxPriorityFeePerGas<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    calculateFeeData(baseFeePerGasFactor?: bigint, alternativeMaxPriorityFeePerGas?: bigint): Promise<FeeData>;
    getFeeData: (baseFeePerGasFactor?: bigint, alternativeMaxPriorityFeePerGas?: bigint) => Promise<FeeData>;
    getAccounts(): Promise<string[]>;
    getBlockNumber<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getBalance<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(address: Address, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getStorageAt<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(address: Address, storageSlot: Numbers, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").ByteTypes[ReturnFormat["bytes"]]>;
    getCode<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(address: Address, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").ByteTypes[ReturnFormat["bytes"]]>;
    getBlock<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(block?: HexString32Bytes | BlockNumberOrTag, hydrated?: boolean, returnFormat?: ReturnFormat): Promise<{
        transactions: string[] | {
            readonly blockHash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockNumber?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly from: string;
            readonly hash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
            readonly transactionIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            to?: string | null | undefined;
            value?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            accessList?: {
                readonly address?: string | undefined;
                readonly storageKeys?: string[] | undefined;
            }[] | undefined;
            common?: {
                customChain: {
                    name?: string | undefined;
                    networkId: import("web3-types").NumberTypes[ReturnFormat["number"]];
                    chainId: import("web3-types").NumberTypes[ReturnFormat["number"]];
                };
                baseChain?: import("web3-types").ValidChains | undefined;
                hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
            } | undefined;
            gas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            gasPrice?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            type?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            maxFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            maxPriorityFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            data?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            input?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            nonce?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            chain?: import("web3-types").ValidChains | undefined;
            hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
            chainId?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            networkId?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            gasLimit?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            yParity?: string | undefined;
            v?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            r?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            s?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        }[];
        parentHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        sha3Uncles: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        miner: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        stateRoot: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        transactionsRoot: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        receiptsRoot: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        logsBloom?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        difficulty?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        number: import("web3-types").NumberTypes[ReturnFormat["number"]];
        gasLimit: import("web3-types").NumberTypes[ReturnFormat["number"]];
        gasUsed: import("web3-types").NumberTypes[ReturnFormat["number"]];
        timestamp: import("web3-types").NumberTypes[ReturnFormat["number"]];
        extraData: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        mixHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        nonce: import("web3-types").NumberTypes[ReturnFormat["number"]];
        totalDifficulty: import("web3-types").NumberTypes[ReturnFormat["number"]];
        baseFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        size: import("web3-types").NumberTypes[ReturnFormat["number"]];
        uncles: string[];
        hash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
    }>;
    getBlockTransactionCount<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(block?: HexString32Bytes | BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getBlockUncleCount<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(block?: HexString32Bytes | BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getUncle<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(block: BlockNumberOrTag | undefined, uncleIndex: Numbers, returnFormat?: ReturnFormat): Promise<{
        readonly parentHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly sha3Uncles: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly miner: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly stateRoot: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly transactionsRoot: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly receiptsRoot: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly logsBloom?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        readonly difficulty?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly number: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly gasLimit: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly gasUsed: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly timestamp: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly extraData: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly mixHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly nonce: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly totalDifficulty: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly baseFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly size: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly transactions: string[] | {
            readonly blockHash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockNumber?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly from: string;
            readonly hash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
            readonly transactionIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            to?: string | null | undefined;
            value?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            accessList?: {
                readonly address?: string | undefined;
                readonly storageKeys?: string[] | undefined;
            }[] | undefined;
            common?: {
                customChain: {
                    name?: string | undefined;
                    networkId: import("web3-types").NumberTypes[ReturnFormat["number"]];
                    chainId: import("web3-types").NumberTypes[ReturnFormat["number"]];
                };
                baseChain?: import("web3-types").ValidChains | undefined;
                hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
            } | undefined;
            gas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            gasPrice?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            type?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            maxFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            maxPriorityFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            data?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            input?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            nonce?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            chain?: import("web3-types").ValidChains | undefined;
            hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
            chainId?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            networkId?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            gasLimit?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            yParity?: string | undefined;
            v?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            r?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            s?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        }[];
        readonly uncles: string[];
        readonly hash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
    }>;
    getTransaction<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transactionHash: Bytes, returnFormat?: ReturnFormat): Promise<{
        readonly yParity: string;
        readonly r: string;
        readonly s: string;
        readonly v?: undefined;
        readonly maxFeePerGas: string;
        readonly maxPriorityFeePerGas: string;
        readonly accessList: {
            readonly address?: string | undefined;
            readonly storageKeys?: string[] | undefined;
        }[];
        readonly gasPrice: string;
        readonly to?: string | null | undefined;
        readonly type: string;
        readonly nonce: string;
        readonly gas: string;
        readonly value: string;
        readonly input: string;
        readonly data?: string | undefined;
        readonly chainId?: string | undefined;
        readonly hash: string;
        readonly blockHash?: string | undefined;
        readonly blockNumber?: string | undefined;
        readonly from: string;
        readonly transactionIndex?: string | undefined;
    } | {
        readonly yParity: string;
        readonly r: string;
        readonly s: string;
        readonly v?: undefined;
        readonly gasPrice: string;
        readonly accessList: {
            readonly address?: string | undefined;
            readonly storageKeys?: string[] | undefined;
        }[];
        readonly maxFeePerGas?: undefined;
        readonly maxPriorityFeePerGas?: undefined;
        readonly to?: string | null | undefined;
        readonly type: string;
        readonly nonce: string;
        readonly gas: string;
        readonly value: string;
        readonly input: string;
        readonly data?: string | undefined;
        readonly chainId?: string | undefined;
        readonly hash: string;
        readonly blockHash?: string | undefined;
        readonly blockNumber?: string | undefined;
        readonly from: string;
        readonly transactionIndex?: string | undefined;
    } | {
        readonly v: string;
        readonly r: string;
        readonly s: string;
        readonly gasPrice: string;
        readonly accessList?: undefined;
        readonly maxFeePerGas?: undefined;
        readonly maxPriorityFeePerGas?: undefined;
        readonly to?: string | null | undefined;
        readonly type: string;
        readonly nonce: string;
        readonly gas: string;
        readonly value: string;
        readonly input: string;
        readonly data?: string | undefined;
        readonly chainId?: string | undefined;
        readonly hash: string;
        readonly blockHash?: string | undefined;
        readonly blockNumber?: string | undefined;
        readonly from: string;
        readonly transactionIndex?: string | undefined;
    }>;
    getPendingTransactions<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<{
        from?: string | undefined;
        to?: string | null | undefined;
        value?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        accessList?: {
            readonly address?: string | undefined;
            readonly storageKeys?: string[] | undefined;
        }[] | undefined;
        common?: {
            customChain: {
                name?: string | undefined;
                networkId: import("web3-types").NumberTypes[ReturnFormat["number"]];
                chainId: import("web3-types").NumberTypes[ReturnFormat["number"]];
            };
            baseChain?: import("web3-types").ValidChains | undefined;
            hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
        } | undefined;
        gas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        gasPrice?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        type?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        maxFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        maxPriorityFeePerGas?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        data?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        input?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        nonce?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        chain?: import("web3-types").ValidChains | undefined;
        hardfork?: "chainstart" | "frontier" | "homestead" | "dao" | "tangerineWhistle" | "spuriousDragon" | "byzantium" | "constantinople" | "petersburg" | "istanbul" | "muirGlacier" | "berlin" | "london" | "altair" | "arrowGlacier" | "grayGlacier" | "bellatrix" | "merge" | "capella" | "shanghai" | undefined;
        chainId?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        networkId?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        gasLimit?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        yParity?: string | undefined;
        v?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        r?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        s?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
    }[]>;
    getTransactionFromBlock<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(block: BlockNumberOrTag | undefined, transactionIndex: Numbers, returnFormat?: ReturnFormat): Promise<{
        readonly yParity: string;
        readonly r: string;
        readonly s: string;
        readonly v?: undefined;
        readonly maxFeePerGas: string;
        readonly maxPriorityFeePerGas: string;
        readonly accessList: {
            readonly address?: string | undefined;
            readonly storageKeys?: string[] | undefined;
        }[];
        readonly gasPrice: string;
        readonly to?: string | null | undefined;
        readonly type: string;
        readonly nonce: string;
        readonly gas: string;
        readonly value: string;
        readonly input: string;
        readonly data?: string | undefined;
        readonly chainId?: string | undefined;
        readonly hash: string;
        readonly blockHash?: string | undefined;
        readonly blockNumber?: string | undefined;
        readonly from: string;
        readonly transactionIndex?: string | undefined;
    } | {
        readonly yParity: string;
        readonly r: string;
        readonly s: string;
        readonly v?: undefined;
        readonly gasPrice: string;
        readonly accessList: {
            readonly address?: string | undefined;
            readonly storageKeys?: string[] | undefined;
        }[];
        readonly maxFeePerGas?: undefined;
        readonly maxPriorityFeePerGas?: undefined;
        readonly to?: string | null | undefined;
        readonly type: string;
        readonly nonce: string;
        readonly gas: string;
        readonly value: string;
        readonly input: string;
        readonly data?: string | undefined;
        readonly chainId?: string | undefined;
        readonly hash: string;
        readonly blockHash?: string | undefined;
        readonly blockNumber?: string | undefined;
        readonly from: string;
        readonly transactionIndex?: string | undefined;
    } | {
        readonly v: string;
        readonly r: string;
        readonly s: string;
        readonly gasPrice: string;
        readonly accessList?: undefined;
        readonly maxFeePerGas?: undefined;
        readonly maxPriorityFeePerGas?: undefined;
        readonly to?: string | null | undefined;
        readonly type: string;
        readonly nonce: string;
        readonly gas: string;
        readonly value: string;
        readonly input: string;
        readonly data?: string | undefined;
        readonly chainId?: string | undefined;
        readonly hash: string;
        readonly blockHash?: string | undefined;
        readonly blockNumber?: string | undefined;
        readonly from: string;
        readonly transactionIndex?: string | undefined;
    } | undefined>;
    getTransactionReceipt<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transactionHash: Bytes, returnFormat?: ReturnFormat): Promise<{
        readonly transactionHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly transactionIndex: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly blockHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly blockNumber: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly from: string;
        readonly to: string;
        readonly cumulativeGasUsed: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly gasUsed: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly effectiveGasPrice?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly contractAddress?: string | undefined;
        readonly logs: {
            readonly id?: string | undefined;
            readonly removed?: boolean | undefined;
            readonly logIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly transactionIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly transactionHash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockHash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly blockNumber?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
            readonly address?: string | undefined;
            readonly data?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
            readonly topics?: import("web3-types").ByteTypes[ReturnFormat["bytes"]][] | undefined;
        }[];
        readonly logsBloom: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly root: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly status: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly type?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        events?: {
            [x: string]: {
                readonly event: string;
                readonly id?: string | undefined;
                readonly logIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly transactionIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly transactionHash?: string | undefined;
                readonly blockHash?: string | undefined;
                readonly blockNumber?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
                readonly address: string;
                readonly topics: string[];
                readonly data: string;
                readonly raw?: {
                    data: string;
                    topics: unknown[];
                } | undefined;
                readonly returnValues: {
                    [x: string]: unknown;
                };
                readonly signature?: string | undefined;
            };
        } | undefined;
    }>;
    getTransactionCount<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(address: Address, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    sendTransaction<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transaction: Transaction | TransactionWithFromLocalWalletIndex | TransactionWithToLocalWalletIndex | TransactionWithFromAndToLocalWalletIndex, returnFormat?: ReturnFormat, options?: SendTransactionOptions): import("web3-core").Web3PromiEvent<import("web3-types").TransactionReceipt, import("./types.js").SendTransactionEvents<ReturnFormat>>;
    sendSignedTransaction<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transaction: Bytes, returnFormat?: ReturnFormat, options?: SendTransactionOptions): import("web3-core").Web3PromiEvent<import("web3-types").TransactionReceipt, import("./types.js").SendSignedTransactionEvents<ReturnFormat>>;
    sign<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(message: Bytes, addressOrIndex: Address | number, returnFormat?: ReturnFormat): Promise<{
        readonly messageHash: string;
        readonly r: string;
        readonly s: string;
        readonly v: string;
        readonly message?: string | undefined;
        readonly signature: string;
    } | import("web3-types").ByteTypes[ReturnFormat["bytes"]]>;
    signTransaction<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transaction: Transaction, returnFormat?: ReturnFormat): Promise<import("web3-types").SignedTransactionInfoAPI>;
    call<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transaction: TransactionCall, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").ByteTypes[ReturnFormat["bytes"]]>;
    estimateGas<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transaction: Transaction, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getPastLogs<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(filter: Filter, returnFormat?: ReturnFormat): Promise<(string | {
        readonly id?: string | undefined;
        readonly removed?: boolean | undefined;
        readonly logIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly transactionIndex?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly transactionHash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        readonly blockHash?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        readonly blockNumber?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
        readonly address?: string | undefined;
        readonly data?: import("web3-types").ByteTypes[ReturnFormat["bytes"]] | undefined;
        readonly topics?: import("web3-types").ByteTypes[ReturnFormat["bytes"]][] | undefined;
    })[]>;
    getWork(): Promise<[string, string, string]>;
    submitWork(nonce: HexString8Bytes, hash: HexString32Bytes, digest: HexString32Bytes): Promise<boolean>;
    requestAccounts(): Promise<string[]>;
    getChainId<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(returnFormat?: ReturnFormat): Promise<import("web3-types").NumberTypes[ReturnFormat["number"]]>;
    getNodeInfo(): Promise<string>;
    getProof<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(address: Address, storageKeys: Bytes[], blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<{
        readonly balance: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly codeHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly nonce: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly storageHash: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
        readonly accountProof: import("web3-types").ByteTypes[ReturnFormat["bytes"]][];
        readonly storageProof: {
            readonly key: import("web3-types").ByteTypes[ReturnFormat["bytes"]];
            readonly value: import("web3-types").NumberTypes[ReturnFormat["number"]];
            readonly proof: import("web3-types").ByteTypes[ReturnFormat["bytes"]][];
        }[];
    }>;
    getFeeHistory<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(blockCount: Numbers, newestBlock: BlockNumberOrTag | undefined, rewardPercentiles: Numbers[], returnFormat?: ReturnFormat): Promise<{
        readonly oldestBlock: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly baseFeePerGas: import("web3-types").NumberTypes[ReturnFormat["number"]];
        readonly reward: import("web3-types").NumberTypes[ReturnFormat["number"]][][];
        readonly gasUsedRatio: import("web3-types").NumberTypes[ReturnFormat["number"]][];
    }>;
    createAccessList<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(transaction: TransactionForAccessList, blockNumber?: BlockNumberOrTag, returnFormat?: ReturnFormat): Promise<{
        readonly accessList?: {
            readonly address?: string | undefined;
            readonly storageKeys?: string[] | undefined;
        }[] | undefined;
        readonly gasUsed?: import("web3-types").NumberTypes[ReturnFormat["number"]] | undefined;
    }>;
    signTypedData<ReturnFormat extends DataFormat = typeof DEFAULT_RETURN_FORMAT>(address: Address, typedData: Eip712TypedData, useLegacy?: boolean, returnFormat?: ReturnFormat): Promise<string>;
    subscribe<T extends keyof RegisteredSubscription, ReturnType extends DataFormat = DataFormat>(name: T, args?: ConstructorParameters<RegisteredSubscription[T]>[0], returnFormat?: ReturnType): Promise<InstanceType<RegisteredSubscription[T]>>;
    private static shouldClearSubscription;
    clearSubscriptions(notClearSyncing?: boolean): Promise<string[]> | undefined;
}
//# sourceMappingURL=web3_eth.d.ts.map